<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binance Bot - Strategy Backtesting</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="/static/chart-utils.js"></script>
    <script src="/static/auth.js"></script>
    <script src="/static/settings.js"></script>
    <script src="/static/utils.js"></script>
    <link rel="stylesheet" href="/static/common.css">
    <script src="/static/common.js"></script>
    <style>
        /* Page-specific styles - common styles are in common.css */
        .container {
            max-width: 1600px; /* Override common.css for this page */
        }

        .content {
            padding: 25px;
        }

        .form-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .form-section h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5em;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .form-group input,
        .form-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            color: #666;
            font-size: 0.85em;
            margin-top: 5px;
        }

        .strategy-params {
            background: white;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .strategy-params h3 {
            margin-bottom: 15px;
            color: #667eea;
        }

        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .results-section {
            display: none;
            margin-top: 25px;
        }

        .results-section.show {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-card h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-card .value.positive {
            color: #28a745;
        }

        .stat-card .value.negative {
            color: #dc3545;
        }

        .ohlc-info-box {
            margin: 0 0 15px 0;
            padding: 8px 12px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .ohlc-content {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .ohlc-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 12px;
        }

        .ohlc-label {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 2px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .ohlc-value {
            color: #333;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .ohlc-value.high {
            color: #4caf50;
        }

        .ohlc-value.low {
            color: #f44336;
        }

        .ohlc-value.ema-fast {
            color: #2196F3;
        }

        .ohlc-value.ema-slow {
            color: #FF9800;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 20px;
        }

        .trades-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .trades-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .trades-table tr:hover {
            background: #f8f9fa;
        }

        .badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge.success {
            background: #d4edda;
            color: #155724;
        }

        .badge.danger {
            background: #f8d7da;
            color: #721c24;
        }

        .badge.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .badge.warning {
            background: #fff3cd;
            color: #856404;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }

        #chartContainer {
            width: 100%;
            min-height: 500px;
            height: auto;
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fff;
            position: relative;
            overflow: hidden;
        }

        .time-presets {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .time-preset-btn {
            padding: 6px 12px;
            background: #e9ecef;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s;
        }

        .time-preset-btn:hover {
            background: #dee2e6;
        }

        /* Walk-forward specific styles */
        .trades-table tr[style*="background-color: #d4edda"] {
            border-left: 3px solid #28a745;
        }

        .trades-table tr[style*="background-color: #f8d7da"] {
            border-left: 3px solid #dc3545;
        }

        /* Optimized params column styling */
        .trades-table th:nth-child(9),
        .trades-table td:nth-child(9) {
            min-width: 350px;
            max-width: 500px;
        }

        .optimized-params-cell {
            font-size: 0.8em;
            line-height: 1.6;
            white-space: normal;
            word-wrap: break-word;
            padding: 10px 12px;
        }

        .optimized-params-cell .param-item {
            display: inline-block;
            margin: 2px 8px 2px 0;
            padding: 2px 6px;
            background: #f0f0f0;
            border-radius: 3px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="menu-toggle" aria-label="Toggle menu" aria-expanded="false">‚ò∞</button>
            <h1>üìä Strategy Backtesting</h1>
            <p>Test your trading strategies on historical market data</p>
            <div class="nav-links">
                <a href="/">üìã Log Viewer</a>
                <a href="/strategies">üèÜ Strategy Performance</a>
                <a href="/market-analyzer">üìà Market Analyzer</a>
                <a href="/trades">üìä Trade & PnL Viewer</a>
                <a href="/reports">üìä Trading Reports</a>
                <a href="/test-accounts/">üîê Test Accounts</a>
                <a href="/strategy-register">üöÄ Register Strategy</a>
                <a href="/static/settings.html">‚öôÔ∏è Settings</a>
                <a href="/docs">üìñ API Docs</a>
                <span id="user-info"></span>
                <a href="#" onclick="logout(); return false;" class="logout-link">üö™ Logout</a>
            </div>
        </div>

        <div class="content">
            <!-- Tab Navigation -->
            <div class="tabs" style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #ddd;">
                <button class="tab-btn active" onclick="switchTab('run')" id="tab-run" style="padding: 12px 24px; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; font-size: 1em; font-weight: 600; color: #666; transition: all 0.3s;">
                    Run Analysis
                </button>
                <button class="tab-btn" onclick="switchTab('history')" id="tab-history" style="padding: 12px 24px; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; font-size: 1em; font-weight: 600; color: #666; transition: all 0.3s;">
                    History
                </button>
                <button class="tab-btn" onclick="switchTab('sensitivity')" id="tab-sensitivity" style="padding: 12px 24px; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; font-size: 1em; font-weight: 600; color: #666; transition: all 0.3s;">
                    Sensitivity Analysis
                </button>
                <a href="/static/walk-forward-dashboard.html" style="padding: 12px 24px; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; font-size: 1em; font-weight: 600; color: #667eea; text-decoration: none; transition: all 0.3s; margin-left: auto;">
                    üìä Dashboard
                </a>
            </div>
            
            <!-- Run Analysis Tab -->
            <div id="tab-content-run" class="tab-content active">
            <div class="form-section">
                <h2>Backtesting Configuration</h2>
                <form id="backtestForm" onsubmit="runBacktest(event)">
                    <div class="form-group" style="grid-column: 1 / -1; margin-bottom: 20px;">
                        <label>Analysis Type *</label>
                        <div style="display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="radio" name="analysisType" value="single" checked onchange="handleAnalysisTypeChange()">
                                <span>Single Backtest</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="radio" name="analysisType" value="walkforward" onchange="handleAnalysisTypeChange()">
                                <span>Walk-Forward Analysis</span>
                            </label>
                        </div>
                        <small>Choose between single period backtest or walk-forward analysis with multiple windows</small>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="symbol">Cryptocurrency Symbol *</label>
                            <input type="text" id="symbol" placeholder="BTCUSDT" required>
                            <small>e.g., BTCUSDT, ETHUSDT</small>
                        </div>

                        <div class="form-group">
                            <label for="strategyType">Strategy Type *</label>
                            <select id="strategyType" required>
                                <option value="">Select strategy...</option>
                                <option value="scalping">EMA Scalping</option>
                                <option value="range_mean_reversion">Range Mean Reversion</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="startTime">Start Time *</label>
                            <input type="datetime-local" id="startTime" required>
                            <small>Beginning of backtesting period</small>
                        </div>

                        <div class="form-group">
                            <label for="endTime">End Time *</label>
                            <input type="datetime-local" id="endTime" required>
                            <small>End of backtesting period</small>
                            <div class="time-presets">
                                <button type="button" class="time-preset-btn" onclick="setTimePreset(1)">Last 1 hour</button>
                                <button type="button" class="time-preset-btn" onclick="setTimePreset(2)">Last 2 hours</button>
                                <button type="button" class="time-preset-btn" onclick="setTimePreset(6)">Last 6 hours</button>
                                <button type="button" class="time-preset-btn" onclick="setTimePreset(24)">Last 24 hours</button>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="leverage">Leverage *</label>
                            <input type="number" id="leverage" min="1" max="50" value="5" required>
                            <small>1-50x leverage</small>
                        </div>

                        <div class="form-group">
                            <label for="riskPerTrade">Risk per Trade *</label>
                            <input type="number" id="riskPerTrade" min="0.001" max="0.1" step="0.001" value="0.01" required>
                            <small>Fraction of balance (0.01 = 1%)</small>
                        </div>

                        <div class="form-group">
                            <label for="fixedAmount">Fixed Amount (Optional)</label>
                            <input type="number" id="fixedAmount" min="0" step="0.01" placeholder="Leave empty to use risk %">
                            <small>Fixed USDT amount per trade (overrides risk %)</small>
                        </div>

                        <div class="form-group">
                            <label for="initialBalance">Initial Balance (USDT) *</label>
                            <input type="number" id="initialBalance" min="1" step="0.01" value="1000" required>
                            <small>Starting capital for backtesting</small>
                        </div>
                    </div>

                    <div class="strategy-params" id="strategyParams">
                        <h3>Strategy Parameters</h3>
                        <div id="paramsContainer">
                            <p style="color: #666;">Select a strategy type to configure parameters</p>
                        </div>
                    </div>

                    <div id="walkForwardConfig" style="display: none;" class="strategy-params">
                        <h3>Walk-Forward Configuration</h3>
                        <div class="params-grid">
                            <div class="form-group">
                                <label for="walkForwardName">Analysis Name</label>
                                <input type="text" id="walkForwardName" maxlength="255" placeholder="e.g., BTC EMA 8/21 WFA - Jan 2025">
                                <small>Optional name to identify this analysis in history</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="trainingPeriodDays">Training Period (Days) *</label>
                                <input type="number" id="trainingPeriodDays" min="7" max="365" value="30" required>
                                <small>Size of training window (7-365 days)</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="testPeriodDays">Test Period (Days) *</label>
                                <input type="number" id="testPeriodDays" min="1" max="90" value="7" required>
                                <small>Size of test window (1-90 days)</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="stepSizeDays">Step Size (Days) *</label>
                                <input type="number" id="stepSizeDays" min="1" max="30" value="7" required>
                                <small>How much to advance each iteration (1-30 days)</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="windowType">Window Type *</label>
                                <select id="windowType" required>
                                    <option value="rolling" selected>Rolling (Fixed-size training window)</option>
                                    <option value="expanding">Expanding (Growing training window)</option>
                                </select>
                                <small>Rolling: fixed-size, Expanding: grows from start</small>
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 6px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                <input type="checkbox" id="enableOptimization" onchange="handleOptimizationToggle()">
                                <span style="font-weight: 600;">Enable Parameter Optimization</span>
                            </label>
                            <small style="display: block; margin-top: 5px; margin-left: 30px; color: #666;">
                                Optimize strategy parameters during training phase
                            </small>
                        </div>
                        
                        <div id="optimizationConfig" style="display: none; margin-top: 20px;">
                            <h4 style="margin-bottom: 15px; color: #667eea;">Optimization Settings</h4>
                            <div class="params-grid">
                                <div class="form-group">
                                    <label for="optimizationMetric">Optimization Metric *</label>
                                    <select id="optimizationMetric" required>
                                        <option value="robust_score" selected>Robust Score (Recommended)</option>
                                        <option value="sharpe_ratio">Sharpe Ratio (uses Robust Score)</option>
                                        <option value="total_return">Total Return</option>
                                        <option value="win_rate">Win Rate</option>
                                        <option value="profit_factor">Profit Factor</option>
                                    </select>
                                    <small>Metric to optimize during training</small>
                                </div>
                                
                                <div class="form-group">
                                    <label for="optimizationMethod">Optimization Method *</label>
                                    <select id="optimizationMethod" required>
                                        <option value="grid_search" selected>Grid Search</option>
                                        <option value="random_search">Random Search</option>
                                    </select>
                                    <small>Optimization algorithm</small>
                                </div>
                            </div>
                            
                            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                                <h4 style="margin-top: 0; margin-bottom: 15px; color: #667eea;">Optimization Guardrails</h4>
                                <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                                    These guardrails prevent overfitting and ensure robust results. Combinations that fail these checks will be rejected.
                                </p>
                                <div class="params-grid">
                                    <div class="form-group">
                                        <label for="minTradesGuardrail">Minimum Trades *</label>
                                        <input type="number" id="minTradesGuardrail" min="1" max="100" value="5" required>
                                        <small>Minimum completed trades required (default: 5). Ensures statistical significance.</small>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="maxDrawdownCap">Max Drawdown Cap (%) *</label>
                                        <input type="number" id="maxDrawdownCap" min="0.1" max="100" step="0.1" value="50.0" required>
                                        <small>Maximum drawdown allowed (default: 50.0%). Rejects combinations exceeding this.</small>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="lotteryTradeThreshold">Lottery Trade Threshold *</label>
                                        <input type="number" id="lotteryTradeThreshold" min="0.1" max="1.0" step="0.01" value="0.5" required>
                                        <small>Rejects if single trade > this % of total profit (default: 0.5 = 50%). Prevents overfitting to lucky trades.</small>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 20px;">
                                <h4 style="margin-bottom: 10px;">Parameters to Optimize</h4>
                                <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">
                                    Select which strategy parameters to optimize. All base parameters are available for optimization (except kline_interval which cannot be optimized).<br>
                                    <strong>Numeric parameters:</strong> Enter multiple values separated by commas (e.g., 5, 8, 10, 12).<br>
                                    <strong>Boolean/Select parameters:</strong> Use the dropdown to select multiple values (hold Ctrl/Cmd to select multiple).<br>
                                    <strong>Note:</strong> Leave a parameter empty to use the base value from Strategy Parameters section.
                                </p>
                                <div id="optimizationParamsBuilder">
                                    <p style="color: #666;">Select a strategy type first to configure optimization parameters</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        <button type="submit" class="btn btn-primary" id="runBtn">Run Backtest</button>
                        <button type="button" class="btn btn-secondary" onclick="resetForm()">Reset</button>
                    </div>
                </form>
            </div>

            <div id="loading" class="loading" style="display: none;">
                <h2 id="loadingTitle">Running backtest...</h2>
                <p id="loadingMessage">This may take a few moments depending on the time period selected.</p>
                
                <!-- Progress tracking (only shown for walk-forward) -->
                <div id="progressContainer" style="display: none; margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span id="progressText">0%</span>
                        <span id="progressTime">--</span>
                        <button id="stopBtn" class="btn btn-danger" style="padding: 8px 16px; font-size: 14px;">Stop Analysis</button>
                    </div>
                    <div style="width: 100%; height: 24px; background-color: #e0e0e0; border-radius: 12px; overflow: hidden;">
                        <div id="progressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4caf50, #8bc34a); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold;">
                        </div>
                    </div>
                    <div id="progressDetails" style="margin-top: 10px; font-size: 14px; color: #666;">
                        <span id="progressPhase"></span>
                    </div>
                </div>
            </div>

            <div id="error" class="error" style="display: none;"></div>

            <div id="results" class="results-section">
                <h2 style="margin-bottom: 20px;" id="resultsTitle">Backtest Results</h2>
                
                <div class="stats-grid" id="statsGrid"></div>

                <div id="equityCurveSection" style="display: none; margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">Equity Curve</h3>
                    <div id="equityCurveContainer" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 8px; background: #fff;"></div>
                </div>

                <div id="windowBreakdownSection" style="display: none; margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">Window Breakdown</h3>
                    <div id="windowBreakdownTable"></div>
                </div>

                <h3 style="margin-top: 30px; margin-bottom: 15px;" id="priceChartTitle">Price Chart with Trade Signals</h3>
                <div id="indicatorControls" style="display: none; margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; font-size: 1.1em;">Indicator Controls</h4>
                    <div id="indicatorToggles" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                </div>
                <div id="chartContainer"></div>

                <h3 style="margin-top: 30px; margin-bottom: 10px;">Trade History</h3>
                <div id="ohlc-info-backtest" class="ohlc-info-box" style="display: none;">
                    <div class="ohlc-content">
                        <div class="ohlc-item">
                            <span class="ohlc-label">Open</span>
                            <span class="ohlc-value" id="ohlc-open-backtest">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">High</span>
                            <span class="ohlc-value high" id="ohlc-high-backtest">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Low</span>
                            <span class="ohlc-value low" id="ohlc-low-backtest">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Close</span>
                            <span class="ohlc-value" id="ohlc-close-backtest">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Change</span>
                            <span class="ohlc-value" id="ohlc-change-backtest">-</span>
                        </div>
                        <div class="ohlc-item" id="ohlc-ema-fast-item-backtest" style="display: none;">
                            <span class="ohlc-label" id="ohlc-ema-fast-label-backtest">EMA</span>
                            <span class="ohlc-value ema-fast" id="ohlc-ema-fast-backtest">-</span>
                        </div>
                        <div class="ohlc-item" id="ohlc-ema-slow-item-backtest" style="display: none;">
                            <span class="ohlc-label" id="ohlc-ema-slow-label-backtest">EMA</span>
                            <span class="ohlc-value ema-slow" id="ohlc-ema-slow-backtest">-</span>
                        </div>
                    </div>
                </div>
                <div id="tradesTable"></div>
            </div>
            </div>
            
            <!-- History Tab -->
            <div id="tab-content-history" class="tab-content" style="display: none;">
                <div class="form-section">
                    <h2>Walk-Forward Analysis History</h2>
                    
                    <!-- Filters -->
                    <div class="form-grid" style="margin-bottom: 20px;">
                        <div class="form-group">
                            <label for="historySymbol">Symbol</label>
                            <input type="text" id="historySymbol" placeholder="Filter by symbol (e.g., BTCUSDT)">
                        </div>
                        <div class="form-group">
                            <label for="historyStrategyType">Strategy Type</label>
                            <select id="historyStrategyType">
                                <option value="">All Strategies</option>
                                <option value="scalping">EMA Scalping</option>
                                <option value="range_mean_reversion">Range Mean Reversion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="historyStartDate">Start Date</label>
                            <input type="date" id="historyStartDate">
                        </div>
                        <div class="form-group">
                            <label for="historyEndDate">End Date</label>
                            <input type="date" id="historyEndDate">
                        </div>
                        <div class="form-group" style="display: flex; align-items: flex-end;">
                            <button type="button" class="btn btn-primary" onclick="loadHistory()" style="width: 100%;">Apply Filters</button>
                        </div>
                    </div>
                    
                    <!-- History Table -->
                    <div id="historyTableContainer" style="background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <div id="historyLoading" style="text-align: center; padding: 40px; color: #666;">
                            Loading history...
                        </div>
                        <div id="historyTable" style="display: none;"></div>
                        <div id="historyEmpty" style="display: none; text-align: center; padding: 40px; color: #666;">
                            <p>No walk-forward analyses found.</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">Run a walk-forward analysis to see results here.</p>
                        </div>
                    </div>
                    
                    <!-- Pagination -->
                    <div id="historyPagination" style="display: none; margin-top: 20px; text-align: center;">
                        <button class="btn btn-secondary" onclick="loadHistoryPage('prev')" id="historyPrevBtn" disabled>Previous</button>
                        <span id="historyPageInfo" style="margin: 0 20px; color: #666;"></span>
                        <button class="btn btn-secondary" onclick="loadHistoryPage('next')" id="historyNextBtn" disabled>Next</button>
                    </div>
                </div>
            </div>
            
            <!-- Sensitivity Analysis Tab -->
            <div id="tab-content-sensitivity" class="tab-content" style="display: none;">
                <div class="form-section">
                    <h2>Parameter Sensitivity Analysis</h2>
                    <p style="color: #666; margin-bottom: 20px;">
                        Test how individual parameter changes affect strategy performance. 
                        This helps identify which parameters matter most before running walk-forward optimization.
                    </p>
                    
                    <form id="sensitivityForm" onsubmit="runSensitivityAnalysis(event)">
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="sensitivityName">Analysis Name</label>
                                <input type="text" id="sensitivityName" placeholder="e.g., BTC EMA Sensitivity Jan 2025">
                                <small>Optional name to identify this analysis</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivitySymbol">Symbol *</label>
                                <input type="text" id="sensitivitySymbol" placeholder="BTCUSDT" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityStrategyType">Strategy Type *</label>
                                <select id="sensitivityStrategyType" required onchange="updateSensitivityParams()">
                                    <option value="">Select strategy...</option>
                                    <option value="scalping">EMA Scalping</option>
                                    <option value="range_mean_reversion">Range Mean Reversion</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityStartTime">Start Time *</label>
                                <input type="datetime-local" id="sensitivityStartTime" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityEndTime">End Time *</label>
                                <input type="datetime-local" id="sensitivityEndTime" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityMetric">Metric to Analyze *</label>
                                <select id="sensitivityMetric" required>
                                    <option value="total_return" selected>Total Return %</option>
                                    <option value="sharpe_ratio">Sharpe Ratio</option>
                                    <option value="win_rate">Win Rate</option>
                                    <option value="profit_factor">Profit Factor</option>
                                    <option value="max_drawdown">Max Drawdown</option>
                                </select>
                                <small>Metric used to measure parameter impact</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityKlineInterval">Kline Interval *</label>
                                <select id="sensitivityKlineInterval" required>
                                    <option value="1m">1m</option>
                                    <option value="3m">3m</option>
                                    <option value="5m" selected>5m</option>
                                    <option value="15m">15m</option>
                                    <option value="30m">30m</option>
                                    <option value="1h">1h</option>
                                    <option value="2h">2h</option>
                                    <option value="4h">4h</option>
                                    <option value="6h">6h</option>
                                    <option value="8h">8h</option>
                                    <option value="12h">12h</option>
                                    <option value="1d">1d</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityLeverage">Leverage *</label>
                                <input type="number" id="sensitivityLeverage" min="1" max="50" value="5" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityRiskPerTrade">Risk Per Trade *</label>
                                <input type="number" id="sensitivityRiskPerTrade" min="0.001" max="0.99" step="0.001" value="0.01" required>
                                <small>Risk percentage per trade (0.01 = 1%)</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityFixedAmount">Fixed Amount (Optional)</label>
                                <input type="number" id="sensitivityFixedAmount" min="0" step="0.01" placeholder="e.g., 100">
                                <small>Fixed USDT amount per trade (overrides risk_per_trade if set)</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="sensitivityInitialBalance">Initial Balance *</label>
                                <input type="number" id="sensitivityInitialBalance" min="1" step="0.01" value="1000" required>
                            </div>
                        </div>
                        
                        <!-- Base Parameters Section -->
                        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <h3 style="margin-top: 0;">Base Parameters</h3>
                            <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">
                                These are the starting parameter values. Each parameter you select for analysis will be varied while keeping others at these base values.
                                <strong>Note:</strong> Kline Interval is set above and cannot be varied as a parameter (it requires fetching different data).
                            </p>
                            <div id="sensitivityBaseParams" class="params-grid">
                                <!-- Dynamically populated based on strategy type -->
                            </div>
                        </div>
                        
                        <!-- Parameters to Analyze Section -->
                        <div style="margin-top: 30px; padding: 20px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                            <h3 style="margin-top: 0;">Parameters to Analyze</h3>
                            <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">
                                Select which parameters to test and specify the values to test for each. 
                                Example: For ema_fast, enter "5,8,10,12,15" to test those values.
                                <strong>Note:</strong> Kline Interval cannot be analyzed (it's set above and requires different data fetches).
                            </p>
                            <div id="sensitivityAnalyzeParams">
                                <!-- Dynamically populated based on strategy type -->
                            </div>
                        </div>
                        
                        <div style="margin-top: 30px; text-align: center;">
                            <button type="submit" class="btn btn-primary" style="padding: 12px 40px; font-size: 1.1em;">
                                Run Sensitivity Analysis
                            </button>
                        </div>
                    </form>
                    
                    <!-- Progress Section -->
                    <div id="sensitivityProgress" style="display: none; margin-top: 30px; padding: 20px; background: #e7f3ff; border-radius: 8px;">
                        <h3>Analysis Progress</h3>
                        <div id="sensitivityProgressBar" style="width: 100%; height: 20px; background: #ddd; border-radius: 10px; overflow: hidden; margin: 10px 0;">
                            <div id="sensitivityProgressFill" style="height: 100%; background: #667eea; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <p id="sensitivityProgressText" style="text-align: center; margin: 10px 0; color: #666;"></p>
                        <button class="btn btn-secondary" onclick="cancelSensitivityAnalysis()" style="margin-top: 10px;">Cancel Analysis</button>
                    </div>
                    
                    <!-- Results Section -->
                    <div id="sensitivityResults" style="display: none; margin-top: 30px;">
                        <h3>Analysis Results</h3>
                        <div id="sensitivityResultsContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check authentication IMMEDIATELY - before any other code runs
        (function() {
            if (!requireAuth()) {
                // Stop execution - page will redirect
                throw new Error('Not authenticated');
            }
        })();
        
        // Strategy parameter templates
        const strategyParams = {
            scalping: {
                kline_interval: { type: 'select', label: 'Kline Interval', value: '1m', options: ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'] },
                ema_fast: { type: 'number', label: 'Fast EMA Period', value: 8, min: 1, max: 200 },
                ema_slow: { type: 'number', label: 'Slow EMA Period', value: 21, min: 2, max: 400 },
                take_profit_pct: { type: 'number', label: 'Take Profit %', value: 0.004, min: 0.001, max: 0.1, step: 0.001 },
                stop_loss_pct: { type: 'number', label: 'Stop Loss %', value: 0.002, min: 0.001, max: 0.1, step: 0.001 },
                enable_short: { type: 'checkbox', label: 'Enable Short Trading', value: true },
                min_ema_separation: { type: 'number', label: 'Min EMA Separation', value: 0.0002, min: 0, max: 0.01, step: 0.0001 },
                enable_htf_bias: { type: 'checkbox', label: 'Enable HTF Bias', value: true },
                cooldown_candles: { type: 'number', label: 'Cooldown Candles', value: 2, min: 0, max: 10 },
                enable_ema_cross_exit: { type: 'checkbox', label: 'Enable EMA Cross Exits', value: true, help: 'If disabled, positions only exit via TP/SL/trailing stop (not via death/golden cross)' },
                trailing_stop_enabled: { type: 'checkbox', label: 'Trailing Stop', value: false },
                trailing_stop_activation_pct: { type: 'number', label: 'Trailing Activation %', value: 0.0, min: 0, max: 0.1, step: 0.001 }
            },
            range_mean_reversion: {
                kline_interval: { type: 'select', label: 'Kline Interval', value: '5m', options: ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'] },
                lookback_period: { type: 'number', label: 'Lookback Period', value: 150, min: 50, max: 500 },
                buy_zone_pct: { type: 'number', label: 'Buy Zone %', value: 0.2, min: 0.01, max: 0.5, step: 0.01 },
                sell_zone_pct: { type: 'number', label: 'Sell Zone %', value: 0.2, min: 0.01, max: 0.5, step: 0.01 },
                ema_fast_period: { type: 'number', label: 'Fast EMA Period', value: 20, min: 5, max: 100 },
                ema_slow_period: { type: 'number', label: 'Slow EMA Period', value: 50, min: 10, max: 200 },
                max_ema_spread_pct: { type: 'number', label: 'Max EMA Spread %', value: 0.005, min: 0, max: 0.02, step: 0.001 },
                max_atr_multiplier: { type: 'number', label: 'Max ATR Multiplier', value: 2.0, min: 0.1, max: 100, step: 0.1 },
                rsi_period: { type: 'number', label: 'RSI Period', value: 14, min: 5, max: 50 },
                rsi_oversold: { type: 'number', label: 'RSI Oversold', value: 40, min: 0, max: 50 },
                rsi_overbought: { type: 'number', label: 'RSI Overbought', value: 60, min: 50, max: 100 },
                tp_buffer_pct: { type: 'number', label: 'TP Buffer %', value: 0.001, min: 0, max: 0.05, step: 0.0001 },
                sl_buffer_pct: { type: 'number', label: 'SL Buffer %', value: 0.002, min: 0, max: 0.05, step: 0.0001 },
                cooldown_candles: { type: 'number', label: 'Cooldown Candles', value: 2, min: 0, max: 10, help: 'Number of candles to wait after exit before allowing new entry (prevents flip-flop entries)' },
                max_range_invalid_candles: { type: 'number', label: 'Max Range Invalid Candles', value: 20, min: 5, max: 100, help: 'Number of consecutive invalid range detections before clearing range state' },
                enable_short: { type: 'checkbox', label: 'Enable Short Trading', value: true }
            }
        };

        // Make function globally accessible
        window.updateStrategyParams = function() {
            try {
                const strategyTypeElement = document.getElementById('strategyType');
                if (!strategyTypeElement) {
                    console.error('Strategy type element not found');
                    return;
                }
                
                const strategyType = strategyTypeElement.value;
            const container = document.getElementById('paramsContainer');
                
                if (!container) {
                    console.error('Params container not found');
                    return;
                }
            
            if (!strategyType || !strategyParams[strategyType]) {
                container.innerHTML = '<p style="color: #666;">Select a strategy type to configure parameters</p>';
                return;
            }

            const params = strategyParams[strategyType];
                if (!params || typeof params !== 'object') {
                    console.error('Invalid strategy params structure for:', strategyType);
                    container.innerHTML = '<p style="color: #d32f2f;">Error: Invalid strategy parameters configuration</p>';
                    return;
                }

            let html = '<div class="params-grid">';
            
            for (const [key, config] of Object.entries(params)) {
                    if (!config || !config.label) {
                        console.warn('Invalid field definition for:', key);
                        continue;
                    }
                    
                html += '<div class="form-group">';
                html += `<label for="param_${key}">${config.label}</label>`;
                
                if (config.type === 'select') {
                    html += `<select id="param_${key}" name="${key}">`;
                        if (config.options && Array.isArray(config.options)) {
                    for (const option of config.options) {
                        html += `<option value="${option}" ${option === config.value ? 'selected' : ''}>${option}</option>`;
                            }
                    }
                    html += '</select>';
                } else if (config.type === 'checkbox') {
                    html += `<input type="checkbox" id="param_${key}" name="${key}" ${config.value ? 'checked' : ''}>`;
                } else {
                        html += `<input type="${config.type}" id="param_${key}" name="${key}" value="${config.value || ''}"`;
                    if (config.min !== undefined) html += ` min="${config.min}"`;
                    if (config.max !== undefined) html += ` max="${config.max}"`;
                    if (config.step !== undefined) html += ` step="${config.step}"`;
                    html += '>';
                }
                
                // Add help text if available
                if (config.help) {
                    html += `<div style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">${config.help}</div>`;
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
                
                console.log('Strategy parameters updated for:', strategyType);
            } catch (error) {
                console.error('Error updating strategy params:', error);
                const container = document.getElementById('paramsContainer');
                if (container) {
                    container.innerHTML = '<p style="color: #d32f2f;">Error loading strategy parameters. Please check the console for details.</p>';
                }
            }
        };

        // Make functions globally accessible
        // formatDateTimeLocal is now in utils.js

        window.setTimePreset = function(hours) {
            try {
                const now = new Date();
                const endTime = new Date(now.getTime() - 60000); // 1 minute ago (to ensure closed candles)
                const startTime = new Date(endTime.getTime() - (hours * 60 * 60 * 1000));
                
                const endTimeInput = document.getElementById('endTime');
                const startTimeInput = document.getElementById('startTime');
                
                if (!endTimeInput || !startTimeInput) {
                    console.error('Time input elements not found');
                    return;
                }
                
                endTimeInput.value = formatDateTimeLocal(endTime);
                startTimeInput.value = formatDateTimeLocal(startTime);
                console.log('Time preset set to last', hours, 'hours');
            } catch (error) {
                console.error('Error setting time preset:', error);
            }
        };

        window.resetForm = function() {
            try {
            document.getElementById('backtestForm').reset();
            document.getElementById('results').classList.remove('show');
            document.getElementById('error').style.display = 'none';
                const strategyTypeSelect = document.getElementById('strategyType');
                if (strategyTypeSelect) {
                    strategyTypeSelect.value = '';
                }
            updateStrategyParams();
            setTimePreset(2); // Default to last 2 hours
            
            // Reset walk-forward config
            const analysisTypeSingle = document.querySelector('input[name="analysisType"][value="single"]');
            if (analysisTypeSingle) {
                analysisTypeSingle.checked = true;
            }
            handleAnalysisTypeChange();
            } catch (error) {
                console.error('Error resetting form:', error);
        }
        };

        window.handleAnalysisTypeChange = function() {
            const analysisType = document.querySelector('input[name="analysisType"]:checked')?.value;
            const walkForwardConfig = document.getElementById('walkForwardConfig');
            const runBtn = document.getElementById('runBtn');
            
            if (analysisType === 'walkforward') {
                if (walkForwardConfig) {
                    walkForwardConfig.style.display = 'block';
                }
                if (runBtn) {
                    runBtn.textContent = 'Run Walk-Forward Analysis';
                }
                // Build optimization params builder if strategy type is selected
                const strategyType = document.getElementById('strategyType')?.value;
                if (strategyType) {
                    buildOptimizationParamsBuilder();
                }
            } else {
                if (walkForwardConfig) {
                    walkForwardConfig.style.display = 'none';
                }
                if (runBtn) {
                    runBtn.textContent = 'Run Backtest';
                }
            }
        };

        window.handleOptimizationToggle = function() {
            const enableOptimization = document.getElementById('enableOptimization')?.checked;
            const optimizationConfig = document.getElementById('optimizationConfig');
            
            if (optimizationConfig) {
                optimizationConfig.style.display = enableOptimization ? 'block' : 'none';
            }
            
            if (enableOptimization) {
                buildOptimizationParamsBuilder();
            }
        };

        window.buildOptimizationParamsBuilder = function() {
            const strategyType = document.getElementById('strategyType')?.value;
            const container = document.getElementById('optimizationParamsBuilder');
            
            if (!strategyType || !container || !strategyParams[strategyType]) {
                if (container) {
                    container.innerHTML = '<p style="color: #666;">Select a strategy type first to configure optimization parameters</p>';
                }
                return;
            }
            
            const params = strategyParams[strategyType];
            let html = '<div class="params-grid">';
            
            // Show ALL parameters except kline_interval
            // CRITICAL: kline_interval cannot be optimized - backend hard-fails if included
            // Interval optimization requires separate datasets per interval, which breaks single-fetch optimization
            for (const [key, config] of Object.entries(params)) {
                if (key === 'kline_interval') continue;  // Exclude kline_interval from optimization
                
                if (config.type === 'checkbox') {
                    // For checkboxes, provide a select dropdown with true/false options
                    html += `
                        <div class="form-group">
                            <label for="opt_param_${key}">${config.label}</label>
                            <select id="opt_param_${key}" multiple style="min-height: 60px;">
                                <option value="true">True</option>
                                <option value="false">False</option>
                            </select>
                            <small>Hold Ctrl/Cmd to select multiple values (or leave empty to use base value)</small>
                        </div>
                    `;
                } else if (config.type === 'select') {
                    // For select dropdowns, allow multiple selection
                    html += `
                        <div class="form-group">
                            <label for="opt_param_${key}">${config.label}</label>
                            <select id="opt_param_${key}" multiple style="min-height: 80px;">
                                ${config.options ? config.options.map(opt => `<option value="${opt}">${opt}</option>`).join('') : ''}
                            </select>
                            <small>Hold Ctrl/Cmd to select multiple values (or leave empty to use base value)</small>
                        </div>
                    `;
                } else {
                    // For numeric inputs, use text input with comma-separated values
                    html += `
                        <div class="form-group">
                            <label for="opt_param_${key}">${config.label}</label>
                            <input 
                                type="text" 
                                id="opt_param_${key}" 
                                placeholder="e.g., 5, 8, 10, 12"
                                pattern="[0-9.,\\s\\-]+"
                            >
                            <small>Comma-separated values to test (or leave empty to use base value)</small>
                        </div>
                    `;
                }
            }
            
            html += '</div>';
            container.innerHTML = html;
        };

        window.getOptimizationParams = function() {
            const enabled = document.getElementById('enableOptimization')?.checked;
            if (!enabled) return null;
            
            const strategyType = document.getElementById('strategyType')?.value;
            if (!strategyType || !strategyParams[strategyType]) return null;
            
            const params = strategyParams[strategyType];
            const optimizeParams = {};
            
            for (const [key, config] of Object.entries(params)) {
                if (key === 'kline_interval') continue;  // Exclude kline_interval from optimization
                
                const input = document.getElementById(`opt_param_${key}`);
                if (!input) continue;
                
                let values = [];
                
                if (config.type === 'checkbox') {
                    // For checkboxes (select dropdown with multiple), get selected options
                    const select = input;
                    const selectedOptions = Array.from(select.selectedOptions);
                    if (selectedOptions.length > 0) {
                        values = selectedOptions.map(opt => opt.value === 'true');
                    }
                } else if (config.type === 'select') {
                    // For select dropdowns with multiple, get selected options
                    const select = input;
                    const selectedOptions = Array.from(select.selectedOptions);
                    if (selectedOptions.length > 0) {
                        values = selectedOptions.map(opt => opt.value);
                    }
                } else {
                    // For text inputs (numeric), parse comma-separated values
                    if (input.value.trim()) {
                        values = input.value.split(',')
                            .map(v => v.trim())
                            .filter(v => v)
                            .map(v => {
                                if (config.type === 'number') {
                                    return parseFloat(v);
                                }
                                return v;
                            });
                    }
                }
                
                if (values.length > 0) {
                    // Require at least 2 values for optimization (otherwise only 1 combination to test)
                    if (values.length === 1) {
                        console.warn(`Parameter ${key} has only 1 value (${values[0]}). Optimization requires at least 2 values to test multiple combinations.`);
                        // Still add it, but warn the user
                    }
                    optimizeParams[key] = values;
                }
            }
            
            return Object.keys(optimizeParams).length > 0 ? optimizeParams : null;
        };

        async function runBacktest(event) {
            event.preventDefault();
            
            const runBtn = document.getElementById('runBtn');
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const results = document.getElementById('results');
            
            // Hide previous results
            error.style.display = 'none';
            results.classList.remove('show');
            
            // Show loading
            runBtn.disabled = true;
            loading.style.display = 'block';
            
            try {
                // Determine analysis type
                const analysisType = document.querySelector('input[name="analysisType"]:checked')?.value || 'single';
                
                // Collect form data
                const strategyType = document.getElementById('strategyType').value;
                const params = {};
                
                // Collect strategy parameters
                const paramInputs = document.querySelectorAll('#strategyParams input, #strategyParams select');
                paramInputs.forEach(input => {
                    const key = input.name || input.id.replace('param_', '');
                    if (input.type === 'checkbox') {
                        params[key] = input.checked;
                    } else if (input.type === 'number') {
                        params[key] = parseFloat(input.value);
                    } else {
                        params[key] = input.value;
                    }
                });
                
                // Build request
                // Note: datetime-local input provides local time string (e.g., "2024-01-15T14:30")
                // new Date() interprets this as LOCAL time, then toISOString() converts to UTC
                // This ensures the backend receives UTC timestamps matching what Binance expects
                const startTimeInput = document.getElementById('startTime').value;
                const endTimeInput = document.getElementById('endTime').value;
                const startDate = new Date(startTimeInput);
                const endDate = new Date(endTimeInput);
                
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    throw new Error('Invalid date/time format');
                }
                
                const baseRequest = {
                    symbol: document.getElementById('symbol').value.toUpperCase(),
                    strategy_type: strategyType,
                    start_time: startDate.toISOString(), // Converts local time to UTC ISO string
                    end_time: endDate.toISOString(), // Converts local time to UTC ISO string
                    leverage: parseInt(document.getElementById('leverage').value),
                    risk_per_trade: parseFloat(document.getElementById('riskPerTrade').value),
                    fixed_amount: document.getElementById('fixedAmount').value ? parseFloat(document.getElementById('fixedAmount').value) : null,
                    initial_balance: parseFloat(document.getElementById('initialBalance').value),
                    params: params
                };
                
                let response;
                let result;
                
                if (analysisType === 'walkforward') {
                    // Validate walk-forward fields
                    const trainingDays = document.getElementById('trainingPeriodDays').value;
                    const testDays = document.getElementById('testPeriodDays').value;
                    const stepDays = document.getElementById('stepSizeDays').value;
                    const windowType = document.getElementById('windowType').value;
                    
                    if (!trainingDays || !testDays || !stepDays || !windowType) {
                        throw new Error('Please fill in all walk-forward configuration fields');
                    }
                    
                    // Build walk-forward request
                    const walkForwardName = document.getElementById('walkForwardName')?.value?.trim() || null;
                    const walkForwardRequest = {
                        ...baseRequest,
                        name: walkForwardName,  // Include name if provided
                        training_period_days: parseInt(trainingDays),
                        test_period_days: parseInt(testDays),
                        step_size_days: parseInt(stepDays),
                        window_type: windowType
                    };
                    
                    // Add optimization params if enabled
                    const enableOptimization = document.getElementById('enableOptimization')?.checked;
                    console.log('Optimization enabled:', enableOptimization);
                    
                    const optimizeParams = getOptimizationParams();
                    console.log('Optimization params from getOptimizationParams():', optimizeParams);
                    
                    if (enableOptimization && !optimizeParams) {
                        throw new Error('Optimization is enabled but no parameters were provided. Please enter values for at least one parameter to optimize.');
                    }
                    
                    if (optimizeParams) {
                        const metric = document.getElementById('optimizationMetric').value;
                        const method = document.getElementById('optimizationMethod').value;
                        
                        console.log('Optimization metric:', metric, 'method:', method);
                        console.log('Optimization params keys:', Object.keys(optimizeParams));
                        console.log('Optimization params values:', optimizeParams);
                        
                        if (!metric || !method) {
                            throw new Error('Please select optimization metric and method when optimization is enabled');
                        }
                        
                        if (Object.keys(optimizeParams).length === 0) {
                            throw new Error('Please provide at least one parameter to optimize');
                        }
                        
                        // Warn if any parameter has only 1 value
                        for (const [paramName, paramValues] of Object.entries(optimizeParams)) {
                            if (paramValues.length === 1) {
                                console.warn(`Warning: Parameter "${paramName}" has only 1 value. Optimization requires at least 2 values per parameter to test multiple combinations.`);
                            }
                        }
                        
                        walkForwardRequest.optimize_params = optimizeParams;
                        walkForwardRequest.optimization_metric = metric;
                        walkForwardRequest.optimization_method = method;
                        
                        // Add guardrail values
                        const minTrades = document.getElementById('minTradesGuardrail')?.value;
                        const maxDrawdown = document.getElementById('maxDrawdownCap')?.value;
                        const lotteryThreshold = document.getElementById('lotteryTradeThreshold')?.value;
                        
                        if (minTrades) {
                            walkForwardRequest.min_trades_guardrail = parseInt(minTrades);
                        }
                        if (maxDrawdown) {
                            walkForwardRequest.max_drawdown_cap = parseFloat(maxDrawdown);
                        }
                        if (lotteryThreshold) {
                            walkForwardRequest.lottery_trade_threshold = parseFloat(lotteryThreshold);
                        }
                    }
                    
                    console.log('Final walkForwardRequest:', JSON.stringify(walkForwardRequest, null, 2));
                    
                    // Show progress UI
                    document.getElementById('loadingTitle').textContent = 'Running Walk-Forward Analysis...';
                    document.getElementById('loadingMessage').textContent = 'Starting analysis...';
                    document.getElementById('progressContainer').style.display = 'block';
                    
                    // Start walk-forward analysis with progress tracking
                    result = await runWalkForwardWithProgress(walkForwardRequest);
                    
                    console.log('Walk-forward result:', result);
                    displayWalkForwardResults(result);
                } else {
                    // Single backtest
                    response = await authFetch('/backtesting/run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                        body: JSON.stringify(baseRequest)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Backtest failed');
                }
                
                    result = await response.json();
                console.log('Backtest result:', result);
                console.log('Total trades:', result.total_trades);
                console.log('Klines data:', result.klines ? result.klines.length : 'No klines');
                displayResults(result);
                }
                
            } catch (err) {
                console.error('Backtest error:', err);
                error.textContent = `Error: ${err.message}`;
                error.style.display = 'block';
            } finally {
                loading.style.display = 'none';
                document.getElementById('progressContainer').style.display = 'none';
                runBtn.disabled = false;
                
                // Clean up EventSource if still open
                if (currentEventSource) {
                    currentEventSource.close();
                    currentEventSource = null;
                }
                currentWalkForwardTaskId = null;
            }
        }

        // Global variable to track current walk-forward task
        let currentWalkForwardTaskId = null;
        let currentEventSource = null;

        async function runWalkForwardWithProgress(walkForwardRequest) {
            return new Promise((resolve, reject) => {
                // Start the analysis
                authFetch('/backtesting/walk-forward/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(walkForwardRequest)
                })
                .then(async response => {
                    // Check if response is OK before parsing JSON
                    if (!response.ok) {
                        // Try to parse error as JSON, fallback to text
                        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                        try {
                            const contentType = response.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                const errorData = await response.json();
                                errorMessage = errorData.detail || errorData.message || errorMessage;
                            } else {
                                // HTML or other non-JSON response
                                const text = await response.text();
                                errorMessage = `Server returned HTML instead of JSON. This usually means an authentication error or server misconfiguration. Status: ${response.status}`;
                                console.error('Non-JSON error response:', text.substring(0, 200));
                            }
                        } catch (e) {
                            // Failed to parse error response
                            console.error('Error parsing error response:', e);
                        }
                        throw new Error(errorMessage);
                    }
                    // Response is OK, parse as JSON
                    return response.json();
                })
                .then(data => {
                    if (!data || !data.task_id) {
                        throw new Error('Invalid response: missing task_id');
                    }
                    currentWalkForwardTaskId = data.task_id;
                    
                    // Set up stop button handler
                    const stopBtn = document.getElementById('stopBtn');
                    stopBtn.onclick = () => {
                        if (currentWalkForwardTaskId) {
                            authFetch(`/backtesting/walk-forward/cancel/${currentWalkForwardTaskId}`, {
                                method: 'POST'
                            }).catch(err => console.error('Error cancelling:', err));
                        }
                    };
                    
                    // Connect to progress stream
                    // Note: EventSource doesn't support custom headers, so we pass token as query param
                    const token = Auth.getToken();
                    const progressUrl = `/backtesting/walk-forward/progress/${data.task_id}?token=${encodeURIComponent(token || '')}`;
                    currentEventSource = new EventSource(progressUrl);
                    
                    let lastProgressData = null;
                    
                    currentEventSource.onmessage = (event) => {
                        try {
                            const progress = JSON.parse(event.data);
                            
                            // Skip if no meaningful change (avoid unnecessary UI updates)
                            if (lastProgressData && 
                                lastProgressData.current_window === progress.current_window &&
                                lastProgressData.status === progress.status) {
                                return;
                            }
                            lastProgressData = progress;
                            
                            // Update progress UI
                            const progressPercent = progress.progress_percent || 0;
                            document.getElementById('progressBar').style.width = progressPercent + '%';
                            document.getElementById('progressText').textContent = progressPercent.toFixed(1) + '%';
                            
                            // Update estimated time
                            if (progress.estimated_time_remaining_seconds !== null && progress.estimated_time_remaining_seconds !== undefined) {
                                const seconds = Math.round(progress.estimated_time_remaining_seconds);
                                const minutes = Math.floor(seconds / 60);
                                const secs = seconds % 60;
                                if (minutes > 0) {
                                    document.getElementById('progressTime').textContent = `~${minutes}m ${secs}s remaining`;
                                } else {
                                    document.getElementById('progressTime').textContent = `~${seconds}s remaining`;
                                }
                            } else {
                                document.getElementById('progressTime').textContent = 'Calculating...';
                            }
                            
                            // Update phase and message
                            const phaseText = progress.message || progress.current_phase || '';
                            document.getElementById('progressPhase').textContent = phaseText;
                            document.getElementById('loadingMessage').textContent = phaseText || 'Processing...';
                            
                            // Check if completed, cancelled, or error
                            if (progress.status === 'completed') {
                                currentEventSource.close();
                                currentEventSource = null;
                                
                                // Fetch the result
                                authFetch(`/backtesting/walk-forward/result/${data.task_id}`, {
                                    method: 'GET'
                                })
                                .then(response => {
                                    if (!response.ok) {
                                        return response.json().then(err => Promise.reject(new Error(err.detail || 'Failed to get result')));
                                    }
                                    return response.json();
                                })
                                .then(result => {
                                    // Debug: Log optimization data for first window
                                    if (result && result.windows && result.windows.length > 0) {
                                        const firstWindow = result.windows[0];
                                        console.log('Walk-forward result received:', {
                                            total_windows: result.windows.length,
                                            first_window: {
                                                window_number: firstWindow.window_number,
                                                has_optimized_params: !!firstWindow.optimized_params,
                                                optimized_params: firstWindow.optimized_params,
                                                optimized_params_type: typeof firstWindow.optimized_params,
                                                optimized_params_keys: firstWindow.optimized_params ? Object.keys(firstWindow.optimized_params) : [],
                                                has_optimization_results: !!firstWindow.optimization_results,
                                                optimization_results: firstWindow.optimization_results,
                                                optimization_results_type: Array.isArray(firstWindow.optimization_results) ? 'array' : typeof firstWindow.optimization_results,
                                                optimization_results_length: Array.isArray(firstWindow.optimization_results) ? firstWindow.optimization_results.length : 'not an array'
                                            }
                                        });
                                    }
                                    resolve(result);
                                })
                                .catch(err => {
                                    reject(err);
                                });
                            } else if (progress.status === 'cancelled') {
                                currentEventSource.close();
                                currentEventSource = null;
                                reject(new Error('Analysis was cancelled'));
                            } else if (progress.status === 'error') {
                                currentEventSource.close();
                                currentEventSource = null;
                                reject(new Error(progress.error || 'Analysis failed'));
                            }
                        } catch (err) {
                            console.error('Error parsing progress:', err);
                        }
                    };
                    
                    currentEventSource.onerror = (err) => {
                        console.error('EventSource error:', err);
                        if (currentEventSource.readyState === EventSource.CLOSED) {
                            // Connection closed - check if it was due to completion
                            // If not completed yet, it might be an error
                            currentEventSource = null;
                            // Don't reject here - let the completion handler deal with it
                        }
                    };
                })
                .catch(err => {
                    console.error('Error starting walk-forward analysis:', err);
                    // Provide user-friendly error message
                    let errorMessage = err.message || 'Failed to start walk-forward analysis';
                    if (errorMessage.includes('HTML instead of JSON')) {
                        errorMessage = 'Authentication error or server misconfiguration. Please check your login status and try again.';
                    }
                    reject(new Error(errorMessage));
                });
            });
        }

        let chart = null;
        let candlestickSeries = null;
        let markersSeries = null;
        let indicatorSeries = {}; // Store all indicator series for toggle control
        let chartRenderer = null; // Will be initialized lazily when needed
        let indicatorToggles = {}; // Store toggle states
        
        // Lazy initialization of chart renderer
        function getChartRenderer() {
            if (!chartRenderer) {
                if (typeof ChartRenderer === 'undefined') {
                    throw new Error('ChartRenderer class not loaded. Please ensure chart-utils.js is loaded correctly.');
                }
                chartRenderer = new ChartRenderer({
                    defaultHeight: 500,
                    secondsVisible: true, // Show seconds for second-based intervals
                    supportRangeMeanReversion: true,
                });
            }
            return chartRenderer;
        }

        function createIndicatorToggles(result) {
            const controlsDiv = document.getElementById('indicatorControls');
            const togglesDiv = document.getElementById('indicatorToggles');
            
            if (!controlsDiv || !togglesDiv) return;
            
            controlsDiv.style.display = 'block';
            
            // Initialize toggle states
            indicatorToggles = {
                rangeLines: true,
                entryZones: true,
                tpSlLevels: true,
                rsi: true,
                emaLines: true,
                emaSpread: false
            };
            
            // Create toggle checkboxes
            togglesDiv.innerHTML = `
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-range-lines" checked>
                    <span>Range Lines (High/Mid/Low)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-entry-zones" checked>
                    <span>Entry Zones (Buy/Sell)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-tp-sl" checked>
                    <span>TP/SL Levels</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-rsi" checked>
                    <span>RSI Panel</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-ema-lines" checked>
                    <span>EMA Lines</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="toggle-ema-spread">
                    <span>EMA Spread</span>
                </label>
            `;
            
            // Add event listeners
            document.getElementById('toggle-range-lines').addEventListener('change', (e) => {
                indicatorToggles.rangeLines = e.target.checked;
                updateIndicatorVisibility();
            });
            document.getElementById('toggle-entry-zones').addEventListener('change', (e) => {
                indicatorToggles.entryZones = e.target.checked;
                updateIndicatorVisibility();
            });
            document.getElementById('toggle-tp-sl').addEventListener('change', (e) => {
                indicatorToggles.tpSlLevels = e.target.checked;
                updateIndicatorVisibility();
            });
            document.getElementById('toggle-rsi').addEventListener('change', (e) => {
                indicatorToggles.rsi = e.target.checked;
                updateIndicatorVisibility();
            });
            document.getElementById('toggle-ema-lines').addEventListener('change', (e) => {
                indicatorToggles.emaLines = e.target.checked;
                updateIndicatorVisibility();
            });
            document.getElementById('toggle-ema-spread').addEventListener('change', (e) => {
                indicatorToggles.emaSpread = e.target.checked;
                updateIndicatorVisibility();
            });
        }

        function updateIndicatorVisibility() {
            // Update visibility of indicator series based on toggle states
            if (indicatorSeries.rangeHigh) {
                indicatorSeries.rangeHigh.applyOptions({ visible: indicatorToggles.rangeLines });
            }
            if (indicatorSeries.rangeMid) {
                indicatorSeries.rangeMid.applyOptions({ visible: indicatorToggles.rangeLines });
            }
            if (indicatorSeries.rangeLow) {
                indicatorSeries.rangeLow.applyOptions({ visible: indicatorToggles.rangeLines });
            }
            if (indicatorSeries.buyZoneUpper) {
                indicatorSeries.buyZoneUpper.applyOptions({ visible: indicatorToggles.entryZones });
            }
            if (indicatorSeries.sellZoneLower) {
                indicatorSeries.sellZoneLower.applyOptions({ visible: indicatorToggles.entryZones });
            }
            // Note: TP/SL price lines visibility is managed by removing/adding them
            // We'll handle this by storing references and removing/adding as needed
            if (indicatorSeries.rsi) {
                indicatorSeries.rsi.applyOptions({ visible: indicatorToggles.rsi });
            }
            if (indicatorSeries.rsiOversold) {
                indicatorSeries.rsiOversold.applyOptions({ visible: indicatorToggles.rsi });
            }
            if (indicatorSeries.rsiOverbought) {
                indicatorSeries.rsiOverbought.applyOptions({ visible: indicatorToggles.rsi });
            }
            if (indicatorSeries.emaFast) {
                indicatorSeries.emaFast.applyOptions({ visible: indicatorToggles.emaLines });
            }
            if (indicatorSeries.emaSlow) {
                indicatorSeries.emaSlow.applyOptions({ visible: indicatorToggles.emaLines });
            }
            if (indicatorSeries.emaSpread) {
                indicatorSeries.emaSpread.applyOptions({ visible: indicatorToggles.emaSpread });
            }
        }

        function addRangeMeanReversionIndicators(chart, candlestickSeries, result) {
            const indicators = result.indicators;
            if (!indicators) return;
            
            // Panel 1: Price + Range overlays (main pane, pane 0)
            // Add range lines
            if (indicators.range_high && indicators.range_low && indicators.range_mid) {
                // Range High (bold line, red)
                indicatorSeries.rangeHigh = chart.addLineSeries({
                    color: '#f44336',
                    lineWidth: 2,
                    title: 'Range High',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: indicatorToggles.rangeLines !== false,
                });
                indicatorSeries.rangeHigh.setData(indicators.range_high);
                
                // Range Mid (dashed line, gray)
                indicatorSeries.rangeMid = chart.addLineSeries({
                    color: '#757575',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Range Mid',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: indicatorToggles.rangeLines !== false,
                });
                indicatorSeries.rangeMid.setData(indicators.range_mid);
                
                // Range Low (bold line, green)
                indicatorSeries.rangeLow = chart.addLineSeries({
                    color: '#4caf50',
                    lineWidth: 2,
                    title: 'Range Low',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: indicatorToggles.rangeLines !== false,
                });
                indicatorSeries.rangeLow.setData(indicators.range_low);
            }
            
            // Add entry zones (boundary lines)
            if (indicators.buy_zone_upper && indicators.range_low) {
                // Buy zone upper boundary (dashed line)
                indicatorSeries.buyZoneUpper = chart.addLineSeries({
                    color: '#4caf50',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Buy Zone Upper',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: indicatorToggles.entryZones !== false,
                });
                indicatorSeries.buyZoneUpper.setData(indicators.buy_zone_upper);
            }
            
            if (indicators.sell_zone_lower && indicators.range_high) {
                // Sell zone lower boundary (dashed line)
                indicatorSeries.sellZoneLower = chart.addLineSeries({
                    color: '#f44336',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Sell Zone Lower',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: indicatorToggles.entryZones !== false,
                });
                indicatorSeries.sellZoneLower.setData(indicators.sell_zone_lower);
            }
            
            // Add TP/SL levels (price lines on candlestick series)
            // Store TP/SL data for dynamic price line creation
            indicatorSeries.tpSlData = [];
            if (indicators.tp_sl_levels && indicators.tp_sl_levels.length > 0 && indicatorToggles.tpSlLevels !== false) {
                indicators.tp_sl_levels.forEach(level => {
                    if (level.tp1 !== null && level.tp1 !== undefined) {
                        candlestickSeries.createPriceLine({
                            price: level.tp1,
                            color: '#2196F3',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP1',
                        });
                    }
                    if (level.tp2 !== null && level.tp2 !== undefined) {
                        candlestickSeries.createPriceLine({
                            price: level.tp2,
                            color: '#00c853',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP2',
                        });
                    }
                    if (level.sl !== null && level.sl !== undefined) {
                        candlestickSeries.createPriceLine({
                            price: level.sl,
                            color: '#f44336',
                            lineWidth: 2,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'SL',
                        });
                    }
                    indicatorSeries.tpSlData.push(level);
                });
            }
            
            // Panel 2: RSI (separate price scale on the right)
            if (indicators.rsi && indicators.rsi.length > 0) {
                // Create RSI series with separate price scale (0-100 range)
                indicatorSeries.rsi = chart.addLineSeries({
                    color: '#9C27B0',
                    lineWidth: 2,
                    title: `RSI (${indicators.rsi_period || 14})`,
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceScaleId: 'rsi', // Use separate price scale
                    visible: indicatorToggles.rsi !== false,
                });
                
                // Configure RSI price scale (0-100 range)
                chart.priceScale('rsi').applyOptions({
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                });
                
                indicatorSeries.rsi.setData(indicators.rsi);
                
                // Add RSI oversold line
                if (indicators.rsi_oversold !== undefined) {
                    indicatorSeries.rsiOversold = chart.addLineSeries({
                        color: '#4caf50',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: `RSI Oversold (${indicators.rsi_oversold})`,
                        priceLineVisible: false,
                        priceScaleId: 'rsi',
                        visible: indicatorToggles.rsi !== false,
                    });
                    const oversoldData = indicators.rsi.map(r => ({
                        time: r.time,
                        value: indicators.rsi_oversold
                    }));
                    indicatorSeries.rsiOversold.setData(oversoldData);
                }
                
                // Add RSI overbought line
                if (indicators.rsi_overbought !== undefined) {
                    indicatorSeries.rsiOverbought = chart.addLineSeries({
                        color: '#f44336',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: `RSI Overbought (${indicators.rsi_overbought})`,
                        priceLineVisible: false,
                        priceScaleId: 'rsi',
                        visible: indicatorToggles.rsi !== false,
                    });
                    const overboughtData = indicators.rsi.map(r => ({
                        time: r.time,
                        value: indicators.rsi_overbought
                    }));
                    indicatorSeries.rsiOverbought.setData(overboughtData);
                }
            }
        }

        function renderChart(result) {
            const chartContainer = document.getElementById('chartContainer');
            
            // Clear previous chart if exists
            if (chart) {
                chart.remove();
            }
            
            if (!result.klines || result.klines.length === 0) {
                chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No chart data available.</p>';
                return;
            }
            
            // Check if library is loaded
            if (typeof LightweightCharts === 'undefined') {
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Chart library failed to load. Please refresh the page.</p>';
                return;
            }
            
            // Determine if this is range mean reversion strategy
            const isRangeMeanReversion = result.strategy_type === 'range_mean_reversion' && 
                                        result.indicators && 
                                        result.indicators.range_high;
            
            // Calculate chart height based on strategy type
            const chartHeight = isRangeMeanReversion ? 800 : 500; // Taller for multi-panel layout
            
            // Update chart container height
            chartContainer.style.height = chartHeight + 'px';
            
            // Create toggle controls for range mean reversion
            if (isRangeMeanReversion) {
                createIndicatorToggles(result);
            } else {
                const controlsDiv = document.getElementById('indicatorControls');
                if (controlsDiv) controlsDiv.style.display = 'none';
            }
            
            // Create chart using shared utility
            try {
                chart = getChartRenderer().createChart(chartContainer, chartHeight);
            } catch (e) {
                console.error('Error creating chart:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error creating chart. Please refresh the page.</p>';
                return;
            }
            
            // Add candlestick series using shared utility
            try {
                candlestickSeries = getChartRenderer().createCandlestickSeries(chart);
            } catch (e) {
                console.error('Error creating candlestick series:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error creating chart series. Please refresh the page.</p>';
                chart.remove();
                chart = null;
                return;
            }
            
            // Process klines data using shared utility
            const candlestickData = getChartRenderer().processKlineData(result.klines); // Remove null entries
            
            if (candlestickData.length === 0) {
                chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No valid chart data available.</p>';
                if (chart) {
                    chart.remove();
                    chart = null;
                }
                return;
            }
            
            // Initialize indicator series storage
            indicatorSeries = {};
            
            // Add Range Mean Reversion indicators if available
            if (isRangeMeanReversion) {
                try {
                    addRangeMeanReversionIndicators(chart, candlestickSeries, result);
                } catch (e) {
                    console.error('Error adding range mean reversion indicators:', e);
                }
            }
            
            // Add EMA indicator lines using shared utility
            try {
                const emaLines = getChartRenderer().addEMALines(chart, result.indicators);
                if (emaLines) {
                    // Store for toggle control
                    indicatorSeries.emaFast = emaLines.emaFast;
                    indicatorSeries.emaSlow = emaLines.emaSlow;
                }
                
                // Add EMA spread line if available (for range mean reversion)
                // Use separate price scale for EMA spread percentage (0-1 range)
                if (isRangeMeanReversion && result.indicators.ema_spread_pct) {
                    const emaSpreadSeries = chart.addLineSeries({
                        color: '#9C27B0',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: 'EMA Spread %',
                        priceLineVisible: false,
                        lastValueVisible: true,
                        priceScaleId: 'emaSpread', // Separate scale for percentage
                    });
                    emaSpreadSeries.setData(result.indicators.ema_spread_pct);
                    indicatorSeries.emaSpread = emaSpreadSeries;
                    
                    // Configure EMA spread price scale
                    chart.priceScale('emaSpread').applyOptions({
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    });
                    
                    // Add max threshold line
                    if (result.indicators.max_ema_spread_pct) {
                        const thresholdValue = result.indicators.max_ema_spread_pct;
                        emaSpreadSeries.createPriceLine({
                            price: thresholdValue,
                            color: '#f44336',
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            axisLabelVisible: true,
                            title: 'Max EMA Spread',
                        });
                    }
                }
            } catch (e) {
                console.warn('Error adding EMA lines:', e);
            }
            
            try {
                candlestickSeries.setData(candlestickData);
            } catch (e) {
                console.error('Error setting chart data:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error loading chart data. Please refresh the page.</p>';
                if (chart) {
                    chart.remove();
                    chart = null;
                }
                return;
            }
            
            // Get fixed OHLC info box above the trades table
            const ohlcBox = document.getElementById('ohlc-info-backtest');
            
            // Show OHLC box when chart is rendered
            if (ohlcBox) {
                ohlcBox.style.display = 'block';
            }
            
            // Setup OHLC display using shared utility
            getChartRenderer().setupOHLCDisplay(chart, candlestickSeries, candlestickData, result.indicators, {
                ohlcBoxId: 'ohlc-info-backtest',
                openId: 'ohlc-open-backtest',
                highId: 'ohlc-high-backtest',
                lowId: 'ohlc-low-backtest',
                closeId: 'ohlc-close-backtest',
                changeId: 'ohlc-change-backtest',
                emaFastItemId: 'ohlc-ema-fast-item-backtest',
                emaFastId: 'ohlc-ema-fast-backtest',
                emaFastLabelId: 'ohlc-ema-fast-label-backtest',
                emaSlowItemId: 'ohlc-ema-slow-item-backtest',
                emaSlowId: 'ohlc-ema-slow-backtest',
                emaSlowLabelId: 'ohlc-ema-slow-label-backtest',
            });
            
            // Add markers for buy/sell signals using shared utility
            const markers = getChartRenderer().createTradeMarkers(result.trades, {
                positionSideField: 'position_side', // backtesting format
                pnlField: 'net_pnl', // backtesting format
                });
                
                if (markers.length > 0) {
                    try {
                        candlestickSeries.setMarkers(markers);
                    } catch (e) {
                        console.warn('Error setting markers:', e);
                }
            }
            
            // Fit content using shared utility
            getChartRenderer().fitContent(chart);
        }

        function displayResults(result) {
            console.log('Displaying results:', result);
            const results = document.getElementById('results');
            const statsGrid = document.getElementById('statsGrid');
            const tradesTable = document.getElementById('tradesTable');
            const resultsTitle = document.getElementById('resultsTitle');
            const priceChartTitle = document.getElementById('priceChartTitle');
            const equityCurveSection = document.getElementById('equityCurveSection');
            const windowBreakdownSection = document.getElementById('windowBreakdownSection');
            
            // Always show results section, even with zero trades
            results.classList.add('show');
            
            // Update title for single backtest
            if (resultsTitle) {
                resultsTitle.textContent = 'Backtest Results';
            }
            
            // Show price chart for single backtest
            if (priceChartTitle) {
                priceChartTitle.style.display = 'block';
            }
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer) {
                chartContainer.style.display = 'block';
            }
            
            // Hide walk-forward sections
            if (equityCurveSection) {
                equityCurveSection.style.display = 'none';
            }
            if (windowBreakdownSection) {
                windowBreakdownSection.style.display = 'none';
            }
            
            // Render chart first
            renderChart(result);
            
            // Display statistics
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>Initial Balance</h3>
                    <div class="value">$${result.initial_balance.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Final Balance</h3>
                    <div class="value ${result.final_balance >= result.initial_balance ? 'positive' : 'negative'}">$${result.final_balance.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Total PnL</h3>
                    <div class="value ${result.total_pnl >= 0 ? 'positive' : 'negative'}">${result.total_pnl >= 0 ? '+' : ''}$${result.total_pnl.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Total Return</h3>
                    <div class="value ${result.total_return_pct >= 0 ? 'positive' : 'negative'}">${result.total_return_pct >= 0 ? '+' : ''}${result.total_return_pct.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Total Trades</h3>
                    <div class="value">${result.total_trades}</div>
                </div>
                <div class="stat-card">
                    <h3>Completed Trades</h3>
                    <div class="value">${result.completed_trades}</div>
                </div>
                <div class="stat-card">
                    <h3>Win Rate</h3>
                    <div class="value ${result.win_rate >= 50 ? 'positive' : 'negative'}">${result.win_rate.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Winning Trades</h3>
                    <div class="value positive">${result.winning_trades}</div>
                </div>
                <div class="stat-card">
                    <h3>Losing Trades</h3>
                    <div class="value negative">${result.losing_trades}</div>
                </div>
                <div class="stat-card">
                    <h3>Total Fees</h3>
                    <div class="value">$${result.total_fees.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Avg Profit/Trade</h3>
                    <div class="value ${result.avg_profit_per_trade >= 0 ? 'positive' : 'negative'}">${result.avg_profit_per_trade >= 0 ? '+' : ''}$${result.avg_profit_per_trade.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Largest Win</h3>
                    <div class="value positive">$${result.largest_win.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Largest Loss</h3>
                    <div class="value negative">$${result.largest_loss.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Max Drawdown</h3>
                    <div class="value negative">$${result.max_drawdown.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <h3>Max Drawdown %</h3>
                    <div class="value negative">${result.max_drawdown_pct.toFixed(2)}%</div>
                </div>
            `;
            
            // Show OHLC info box
            const ohlcBox = document.getElementById('ohlc-info-backtest');
            if (ohlcBox) {
                ohlcBox.style.display = 'block';
            }
            
            // Display trades table
            if (result.trades && result.trades.length > 0) {
                let html = '<table class="trades-table"><thead><tr>';
                html += '<th>Entry Time</th>';
                html += '<th>Exit Time</th>';
                html += '<th>Side</th>';
                html += '<th>Entry Price</th>';
                html += '<th>Exit Price</th>';
                html += '<th>Quantity</th>';
                html += '<th>Gross PnL</th>';
                html += '<th>Net PnL</th>';
                html += '<th>Fees</th>';
                html += '<th>Exit Reason</th>';
                html += '</tr></thead><tbody>';
                
                result.trades.forEach(trade => {
                    // Use UserSettings if available, otherwise fallback to UTC format
                    const formatDate = (dateString) => {
                        if (!dateString) return 'Open';
                        if (typeof UserSettings !== 'undefined') {
                            return UserSettings.formatDate(dateString);
                        }
                        // Fallback for when settings.js is not loaded
                        const date = new Date(dateString);
                        if (isNaN(date.getTime())) return 'Invalid';
                        const year = date.getUTCFullYear();
                        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                        const day = String(date.getUTCDate()).padStart(2, '0');
                        const hours = String(date.getUTCHours()).padStart(2, '0');
                        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
                    };
                    const entryTime = formatDate(trade.entry_time);
                    const exitTime = formatDate(trade.exit_time);
                    const sideClass = trade.position_side === 'LONG' ? 'success' : 'danger';
                    const pnlClass = trade.net_pnl && trade.net_pnl >= 0 ? 'positive' : 'negative';
                    const totalFees = trade.entry_fee + (trade.exit_fee || 0);
                    
                    html += '<tr>';
                    html += `<td>${entryTime}</td>`;
                    html += `<td>${exitTime}</td>`;
                    html += `<td><span class="badge ${sideClass}">${trade.position_side}</span></td>`;
                    html += `<td>$${trade.entry_price.toFixed(5)}</td>`;
                    html += `<td>${trade.exit_price ? '$' + trade.exit_price.toFixed(5) : '-'}</td>`;
                    html += `<td>${trade.quantity.toFixed(5)}</td>`;
                    html += `<td class="${pnlClass}">${trade.pnl ? (trade.pnl >= 0 ? '+' : '') + '$' + trade.pnl.toFixed(2) : '-'}</td>`;
                    html += `<td class="${pnlClass}">${trade.net_pnl ? (trade.net_pnl >= 0 ? '+' : '') + '$' + trade.net_pnl.toFixed(2) : '-'}</td>`;
                    html += `<td>$${totalFees.toFixed(2)}</td>`;
                    html += `<td>${trade.exit_reason || '-'}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                tradesTable.innerHTML = html;
            } else {
                tradesTable.innerHTML = '<p style="color: #666; padding: 20px;">No trades executed during this period.</p>';
            }
            
            results.classList.add('show');
        }

        let equityChart = null;

        function displayWalkForwardResults(result) {
            console.log('Displaying walk-forward results:', result);
            const results = document.getElementById('results');
            const statsGrid = document.getElementById('statsGrid');
            const resultsTitle = document.getElementById('resultsTitle');
            const priceChartTitle = document.getElementById('priceChartTitle');
            const equityCurveSection = document.getElementById('equityCurveSection');
            const windowBreakdownSection = document.getElementById('windowBreakdownSection');
            
            // Show results section
            results.classList.add('show');
            
            // Update title
            if (resultsTitle) {
                resultsTitle.textContent = 'Walk-Forward Analysis Results';
            }
            
            // Hide price chart for walk-forward (focus on equity curve)
            if (priceChartTitle) {
                priceChartTitle.style.display = 'none';
            }
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer) {
                chartContainer.style.display = 'none';
            }
            
            // Show equity curve and window breakdown
            if (equityCurveSection) {
                equityCurveSection.style.display = 'block';
            }
            if (windowBreakdownSection) {
                windowBreakdownSection.style.display = 'block';
            }
            
            // Display aggregate statistics
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>Total Return (Compounded)</h3>
                    <div class="value ${result.total_return_pct >= 0 ? 'positive' : 'negative'}">
                        ${result.total_return_pct >= 0 ? '+' : ''}${result.total_return_pct.toFixed(2)}%
                    </div>
                </div>
                <div class="stat-card">
                    <h3>Average Window Return</h3>
                    <div class="value ${result.avg_window_return_pct >= 0 ? 'positive' : 'negative'}">
                        ${result.avg_window_return_pct >= 0 ? '+' : ''}${result.avg_window_return_pct.toFixed(2)}%
                    </div>
                </div>
                <div class="stat-card">
                    <h3>Consistency Score</h3>
                    <div class="value ${result.consistency_score >= 50 ? 'positive' : 'negative'}">
                        ${result.consistency_score.toFixed(1)}%
                    </div>
                </div>
                <div class="stat-card">
                    <h3>Sharpe Ratio</h3>
                    <div class="value ${result.sharpe_ratio >= 1 ? 'positive' : result.sharpe_ratio >= 0 ? '' : 'negative'}">
                        ${result.sharpe_ratio.toFixed(2)}
                    </div>
                </div>
                <div class="stat-card">
                    <h3>Max Drawdown</h3>
                    <div class="value negative">${result.max_drawdown_pct.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Total Trades</h3>
                    <div class="value">${result.total_trades}</div>
                </div>
                <div class="stat-card">
                    <h3>Average Win Rate</h3>
                    <div class="value ${result.avg_win_rate >= 50 ? 'positive' : 'negative'}">
                        ${result.avg_win_rate.toFixed(2)}%
                    </div>
                </div>
                <div class="stat-card">
                    <h3>Return Std Dev</h3>
                    <div class="value">${result.return_std_dev.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Total Windows</h3>
                    <div class="value">${result.total_windows}</div>
                </div>
                <div class="stat-card">
                    <h3>Best Window</h3>
                    <div class="value positive">#${result.best_window}</div>
                </div>
                <div class="stat-card">
                    <h3>Worst Window</h3>
                    <div class="value negative">#${result.worst_window}</div>
                </div>
            `;
            
            // Render equity curve with initial balance
            console.log('Equity curve check:', {
                has_equity_curve: !!result.equity_curve,
                equity_curve_length: result.equity_curve ? result.equity_curve.length : 0,
                equity_curve_sample: result.equity_curve ? result.equity_curve.slice(0, 3) : null,
                initial_balance: result.initial_balance,
                result_keys: Object.keys(result)
            });
            
            if (result.equity_curve && result.equity_curve.length > 0) {
                console.log('Rendering equity curve with', result.equity_curve.length, 'points');
                renderEquityCurve(result.equity_curve, result.initial_balance);
            } else {
                console.warn('Equity curve is missing or empty!', {
                    equity_curve: result.equity_curve,
                    initial_balance: result.initial_balance
                });
            }
            
            // Display window breakdown
            if (result.windows && result.windows.length > 0) {
                // Debug: Log window data to verify training returns and optimization data
                console.log('Walk-Forward Windows Data:', result.windows.map(w => ({
                    window: w.window_number,
                    training_period: `${w.training_start} to ${w.training_end}`,
                    training_return: w.training_return_pct,
                    test_period: `${w.test_start} to ${w.test_end}`,
                    test_return: w.test_return_pct,
                    has_optimized_params: !!w.optimized_params && Object.keys(w.optimized_params || {}).length > 0,
                    optimized_params: w.optimized_params,
                    has_optimization_results: !!w.optimization_results && Array.isArray(w.optimization_results) && w.optimization_results.length > 0,
                    optimization_results_count: w.optimization_results ? (Array.isArray(w.optimization_results) ? w.optimization_results.length : 'not an array') : 0
                })));
                displayWindowBreakdown(result.windows, result.best_window, result.worst_window);
            }
        }

        function renderEquityCurve(equityCurve, initialBalance = null) {
            const chartContainer = document.getElementById('equityCurveContainer');
            if (!chartContainer) return;
            
            // Clear previous chart
            if (equityChart) {
                equityChart.remove();
                equityChart = null;
            }
            
            // Check if library is loaded
            if (typeof LightweightCharts === 'undefined') {
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Chart library failed to load. Please refresh the page.</p>';
                return;
            }
            
            if (!equityCurve || equityCurve.length === 0) {
                chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No equity curve data available.</p>';
                return;
            }
            
            try {
                // Filter and validate data, then sort by time
                const validData = equityCurve.filter(point => {
                    if (!point) return false;
                    if (point.time === null || point.time === undefined) return false;
                    if (point.balance === null || point.balance === undefined) return false;
                    if (isNaN(point.balance) || !isFinite(point.balance)) return false;
                    return true;
                });
                
                if (validData.length === 0) {
                    chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No valid equity curve data available.</p>';
                    return;
                }
                
                // Sort data by time to ensure proper rendering
                const sortedData = validData.sort((a, b) => {
                    const timeA = typeof a.time === 'number' ? a.time : (typeof a.time === 'string' ? new Date(a.time).getTime() / 1000 : 0);
                    const timeB = typeof b.time === 'number' ? b.time : (typeof b.time === 'string' ? new Date(b.time).getTime() / 1000 : 0);
                    return timeA - timeB;
                });
                
                // Calculate initial balance if not provided (use first point)
                const startBalance = initialBalance || sortedData[0]?.balance || 1000;
                
                // Calculate drawdown for each point
                let peak = startBalance;
                const drawdownData = [];
                const equityData = [];
                
                // Get user's timezone preference for equity curve display
                const useUTC = typeof UserSettings !== 'undefined' && UserSettings.get('timeFormat') === 'utc';
                let timezoneOffsetSeconds = 0;
                if (useUTC) {
                    // Get browser's timezone offset in minutes, convert to seconds
                    // We ADD the offset to timestamps so local display shows UTC
                    timezoneOffsetSeconds = new Date().getTimezoneOffset() * 60; // Convert minutes to seconds
                }
                
                sortedData.forEach(point => {
                    // Validate and filter out null/undefined values
                    if (!point || point.time === null || point.time === undefined) {
                        console.warn('Skipping invalid point (missing time):', point);
                        return;
                    }
                    
                    const balance = point.balance;
                    // Validate balance is a valid number
                    if (balance === null || balance === undefined || isNaN(balance) || !isFinite(balance)) {
                        console.warn('Skipping invalid point (invalid balance):', point);
                        return;
                    }
                    
                    if (balance > peak) {
                        peak = balance;
                    }
                    const drawdown = peak - balance;
                    const drawdownPct = peak > 0 ? (drawdown / peak) * 100 : 0;
                    
                    // Ensure time is a valid number (convert to Unix timestamp if needed)
                    let timeValue = point.time;
                    if (typeof timeValue === 'string') {
                        timeValue = Math.floor(new Date(timeValue).getTime() / 1000);
                    } else if (timeValue instanceof Date) {
                        timeValue = Math.floor(timeValue.getTime() / 1000);
                    }
                    
                    if (isNaN(timeValue) || !isFinite(timeValue)) {
                        console.warn('Skipping invalid point (invalid time):', point);
                        return;
                    }
                    
                    // Adjust timestamp for UTC display if needed (same as kline data)
                    const adjustedTime = useUTC ? timeValue + timezoneOffsetSeconds : timeValue;
                    
                    equityData.push({
                        time: adjustedTime,
                        value: Number(balance)
                    });
                    
                    drawdownData.push({
                        time: adjustedTime,
                        value: -drawdownPct // Negative for visualization
                    });
                });
                
                // Note: Timezone adjustment for equity chart is handled by adjusting timestamps in the data
                // Lightweight Charts doesn't support custom timezone formatting via localization API
                // Create chart with better configuration
                equityChart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.clientWidth,
                    height: 500, // Increased height for better visibility
                    layout: {
                        background: { color: '#ffffff' },
                        textColor: '#333',
                        fontSize: 12,
                    },
                    grid: {
                        vertLines: { 
                            color: '#e0e0e0',
                            style: 1, // Solid
                        },
                        horzLines: { 
                            color: '#e0e0e0',
                            style: 1, // Solid
                        },
                    },
                    timeScale: {
                        timeVisible: true,
                        secondsVisible: false,
                        borderColor: '#d1d4dc',
                    },
                    rightPriceScale: {
                        borderColor: '#d1d4dc',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    crosshair: {
                        mode: 1, // Normal mode
                        vertLine: {
                            color: '#758696',
                            width: 1,
                            style: 3, // Dashed
                            labelBackgroundColor: '#667eea',
                        },
                        horzLine: {
                            color: '#758696',
                            width: 1,
                            style: 3, // Dashed
                            labelBackgroundColor: '#667eea',
                        },
                    },
                });
                
                // Create equity curve line series (main)
                const equitySeries = equityChart.addLineSeries({
                    color: '#667eea',
                    lineWidth: 2,
                    title: 'Equity Curve',
                    priceFormat: {
                        type: 'price',
                        precision: 2,
                        minMove: 0.01,
                    },
                    lastValueVisible: true,
                    priceLineVisible: false,
                });
                
                // Add initial balance reference line
                if (sortedData.length > 0) {
                    const initialBalanceLine = equityChart.addLineSeries({
                        color: '#9e9e9e',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: 'Initial Balance',
                        priceFormat: {
                            type: 'price',
                            precision: 2,
                            minMove: 0.01,
                        },
                        lastValueVisible: true,
                        priceLineVisible: false,
                    });
                    
                    // Ensure time values are valid numbers
                    const startTime = typeof sortedData[0].time === 'number' ? sortedData[0].time : 
                                     (typeof sortedData[0].time === 'string' ? Math.floor(new Date(sortedData[0].time).getTime() / 1000) : null);
                    const endTime = typeof sortedData[sortedData.length - 1].time === 'number' ? sortedData[sortedData.length - 1].time :
                                   (typeof sortedData[sortedData.length - 1].time === 'string' ? Math.floor(new Date(sortedData[sortedData.length - 1].time).getTime() / 1000) : null);
                    
                    if (startTime && endTime && isFinite(startTime) && isFinite(endTime) && isFinite(startBalance)) {
                        initialBalanceLine.setData([
                            { time: startTime, value: Number(startBalance) },
                            { time: endTime, value: Number(startBalance) }
                        ]);
                    } else {
                        console.warn('Skipping initial balance line due to invalid time values', { startTime, endTime, startBalance });
                    }
                }
                
                // Create drawdown area series (in separate pane)
                const drawdownSeries = equityChart.addLineSeries({
                    color: '#f44336',
                    lineWidth: 1,
                    title: 'Drawdown %',
                    priceFormat: {
                        type: 'price',
                        precision: 2,
                        minMove: 0.01,
                    },
                    lastValueVisible: true,
                    priceLineVisible: false,
                    priceScaleId: 'drawdown', // Use separate scale
                });
                
                // Set data
                equitySeries.setData(equityData);
                if (drawdownData.length > 0) {
                    drawdownSeries.setData(drawdownData);
                }
                
                // Fit content to show all data
                equityChart.timeScale().fitContent();
                
                // Add legend/controls
                const legend = document.createElement('div');
                legend.style.cssText = 'position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 10;';
                legend.innerHTML = `
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div><span style="color: #667eea; font-weight: bold;">‚óè</span> Equity</div>
                        <div><span style="color: #9e9e9e; font-weight: bold;">‚îÄ</span> Initial Balance</div>
                        <div><span style="color: #f44336; font-weight: bold;">‚óè</span> Drawdown</div>
                    </div>
                `;
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(legend);
                
            } catch (e) {
                console.error('Error rendering equity curve:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error rendering equity curve chart: ' + e.message + '</p>';
            }
        }

        function displayWindowBreakdown(windows, bestWindow, worstWindow) {
            // Debug: Log window data before processing
            console.log('displayWindowBreakdown called with:', {
                windows_count: windows ? windows.length : 0,
                bestWindow,
                worstWindow,
                first_window_sample: windows && windows.length > 0 ? {
                    window_number: windows[0].window_number,
                    optimized_params: windows[0].optimized_params,
                    optimization_results: windows[0].optimization_results,
                    optimization_results_type: Array.isArray(windows[0].optimization_results) ? 'array' : typeof windows[0].optimization_results,
                    optimization_results_length: Array.isArray(windows[0].optimization_results) ? windows[0].optimization_results.length : 'not an array'
                } : null
            });
            const container = document.getElementById('windowBreakdownTable');
            if (!container) return;
            
            // Format date helper
            const formatDate = (dateString) => {
                if (!dateString) return '-';
                if (typeof UserSettings !== 'undefined') {
                    return UserSettings.formatDate(dateString);
                }
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Invalid';
                const year = date.getUTCFullYear();
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const day = String(date.getUTCDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            let html = '<div style="margin-bottom: 15px;"><button onclick="sortWindowTable(\'return\')" style="margin-right: 10px; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Sort by Return</button>';
            html += '<button onclick="sortWindowTable(\'trades\')" style="margin-right: 10px; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Sort by Trades</button>';
            html += '<button onclick="sortWindowTable(\'window\')" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Sort by Window</button></div>';
            html += '<table class="trades-table" id="windowBreakdownTableData"><thead><tr>';
            html += '<th>Window</th>';
            html += '<th>Training Period</th>';
            html += '<th>Test Period</th>';
            html += '<th>Training Return</th>';
            html += '<th>Test Return</th>';
            html += '<th>Test Win Rate</th>';
            html += '<th>Test Trades</th>';
            html += '<th>Test Sharpe</th>';
            html += '<th>Optimized Params</th>';
            html += '<th>Training Combinations</th>';
            html += '</tr></thead><tbody>';
            
            windows.forEach((window, index) => {
                const isBest = window.window_number === bestWindow;
                const isWorst = window.window_number === worstWindow;
                const rowClass = isBest ? 'style="background-color: #d4edda;"' : 
                                isWorst ? 'style="background-color: #f8d7da;"' : '';
                
                // Debug: Log individual window data
                console.log(`Window ${window.window_number}:`, {
                    training_start: window.training_start,
                    training_end: window.training_end,
                    training_return_pct: window.training_return_pct,
                    test_start: window.test_start,
                    test_end: window.test_end,
                    test_return_pct: window.test_return_pct,
                    training_result: window.training_result ? {
                        total_return_pct: window.training_result.total_return_pct,
                        final_balance: window.training_result.final_balance
                    } : null
                });
                
                // Format optimized params better - show ALL parameters that were optimized
                let optimizedParamsDisplay = '-';
                let optimizedParamsTooltip = '';
                
                // Debug: Log optimized_params check
                console.log(`Window ${window.window_number} optimized_params check:`, {
                    optimized_params: window.optimized_params,
                    optimized_params_type: typeof window.optimized_params,
                    optimized_params_is_null: window.optimized_params === null,
                    optimized_params_is_undefined: window.optimized_params === undefined,
                    optimized_params_is_object: typeof window.optimized_params === 'object',
                    optimized_params_keys: window.optimized_params ? Object.keys(window.optimized_params) : [],
                    optimized_params_keys_length: window.optimized_params ? Object.keys(window.optimized_params).length : 0,
                    check_result: window.optimized_params && typeof window.optimized_params === 'object' && Object.keys(window.optimized_params).length > 0
                });
                
                // Check if optimized_params exists and is not empty (handle both null/undefined and empty objects)
                if (window.optimized_params && typeof window.optimized_params === 'object' && Object.keys(window.optimized_params).length > 0) {
                    try {
                        const params = window.optimized_params;
                        // Sort parameters for consistent display
                        const sortedEntries = Object.entries(params).sort(([a], [b]) => a.localeCompare(b));
                        const paramPairs = sortedEntries.map(([key, value]) => {
                            // Format value based on type
                            let formattedValue = value;
                            if (typeof value === 'number') {
                                // Show integers as-is, decimals with appropriate precision
                                if (Number.isInteger(value)) {
                                    formattedValue = value;
                                } else if (key.includes('pct') || key.includes('percent')) {
                                    formattedValue = (value * 100).toFixed(2) + '%';
                                } else {
                                    formattedValue = value.toFixed(4);
                                }
                            }
                            // Create HTML for each parameter item
                            return `<span class="param-item"><strong>${key}:</strong> ${formattedValue}</span>`;
                        });
                        // Show all parameters as HTML with styling
                        optimizedParamsDisplay = paramPairs.join('');
                        optimizedParamsTooltip = sortedEntries.map(([key, value]) => {
                            let formattedValue = value;
                            if (typeof value === 'number') {
                                if (Number.isInteger(value)) {
                                    formattedValue = value;
                                } else if (key.includes('pct') || key.includes('percent')) {
                                    formattedValue = (value * 100).toFixed(2) + '%';
                                } else {
                                    formattedValue = value.toFixed(4);
                                }
                            }
                            return `${key}: ${formattedValue}`;
                        }).join('\n'); // Newline for better readability in tooltip
                    } catch (e) {
                        console.error('Error formatting optimized params:', e, window.optimized_params);
                        optimizedParamsDisplay = JSON.stringify(window.optimized_params);
                        optimizedParamsTooltip = optimizedParamsDisplay;
                    }
                }
                
                html += `<tr ${rowClass}>`;
                html += `<td><strong>${window.window_number}</strong>${isBest ? ' ‚≠ê' : ''}${isWorst ? ' ‚ö†Ô∏è' : ''}</td>`;
                html += `<td>${formatDate(window.training_start)}<br>to ${formatDate(window.training_end)}</td>`;
                html += `<td>${formatDate(window.test_start)}<br>to ${formatDate(window.test_end)}</td>`;
                html += `<td class="${window.training_return_pct >= 0 ? 'positive' : 'negative'}">${window.training_return_pct >= 0 ? '+' : ''}${window.training_return_pct.toFixed(2)}%</td>`;
                html += `<td class="${window.test_return_pct >= 0 ? 'positive' : 'negative'}">${window.test_return_pct >= 0 ? '+' : ''}${window.test_return_pct.toFixed(2)}%</td>`;
                html += `<td>${window.test_win_rate.toFixed(2)}%</td>`;
                html += `<td>${window.test_result?.total_trades || 0}</td>`;
                html += `<td>${window.test_sharpe !== null && window.test_sharpe !== undefined ? window.test_sharpe.toFixed(2) : 'N/A'}</td>`;
                // Show optimized params with better formatting and full tooltip
                html += `<td class="optimized-params-cell" title="${optimizedParamsTooltip || optimizedParamsDisplay}">${optimizedParamsDisplay}</td>`;
                
                // Add button to view optimization results if available
                // Check if optimization_results exists, is an array, and has items
                
                // Debug: Log optimization_results check
                console.log(`Window ${window.window_number} optimization_results check:`, {
                    optimization_results: window.optimization_results,
                    optimization_results_type: typeof window.optimization_results,
                    optimization_results_is_array: Array.isArray(window.optimization_results),
                    optimization_results_length: Array.isArray(window.optimization_results) ? window.optimization_results.length : 'not an array',
                    check_result: window.optimization_results && Array.isArray(window.optimization_results) && window.optimization_results.length > 0
                });
                
                if (window.optimization_results && Array.isArray(window.optimization_results) && window.optimization_results.length > 0) {
                    html += `<td><button onclick="showOptimizationResults(${window.window_number})" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">View All Combinations (${window.optimization_results.length})</button></td>`;
                } else {
                    html += '<td>-</td>';
                }
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Store windows data for sorting
            window.windowBreakdownData = windows;
        }
        
        // Function to show optimization results for a specific window
        function showOptimizationResults(windowNumber) {
            // Try to get data from either live results or history modal
            const windowData = (window.windowBreakdownData || window.historyWindowBreakdownData || []).find(w => (w.window_number || w.windowNumber) === windowNumber);
            
            if (!windowData) {
                console.error('Window breakdown data not available for window', windowNumber);
                alert(`No data available for Window ${windowNumber}`);
                return;
            }
            
            if (!windowData.optimization_results || !Array.isArray(windowData.optimization_results) || windowData.optimization_results.length === 0) {
                alert(`No optimization results available for Window ${windowNumber}`);
                return;
            }
            
            const results = windowData.optimization_results;
            
            // Create modal or expandable section
            const modal = document.createElement('div');
            modal.id = 'optimizationResultsModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                overflow-y: auto;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 95%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;
            
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Training Data Optimization Results - Window ${windowNumber}</h2>
                    <button onclick="closeOptimizationResults()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Close</button>
                </div>
                <p style="color: #666; margin-bottom: 15px;">
                    All parameter combinations tested during training phase. Results are sorted by score (best first).
                </p>
                <table class="trades-table" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Status</th>
                            <th>Parameters</th>
                            <th>Score</th>
                            <th>Return %</th>
                            <th>Trades</th>
                            <th>Win Rate</th>
                            <th>Max DD %</th>
                            <th>Sharpe</th>
                            <th>Failure Reason</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Sort results by score (best first), with failed/error at the end
            const sortedResults = [...results].sort((a, b) => {
                if (a.status === 'error') return 1;
                if (b.status === 'error') return -1;
                if (a.status === 'failed') return 1;
                if (b.status === 'failed') return -1;
                if (a.score === null) return 1;
                if (b.score === null) return -1;
                return (b.score || 0) - (a.score || 0);
            });
            
            sortedResults.forEach((result, index) => {
                const isBest = index === 0 && result.status === 'passed';
                const rowStyle = isBest ? 'background-color: #d4edda; font-weight: bold;' : 
                                result.status === 'failed' ? 'background-color: #fff3cd;' :
                                result.status === 'error' ? 'background-color: #f8d7da;' : '';
                
                html += `<tr style="${rowStyle}">`;
                html += `<td>${result.combination_number}</td>`;
                
                // Status column
                let statusBadge = '';
                if (result.status === 'passed') {
                    statusBadge = '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em;">PASSED</span>';
                } else if (result.status === 'failed') {
                    statusBadge = '<span style="background: #ffc107; color: #000; padding: 2px 8px; border-radius: 3px; font-size: 0.85em;">FAILED</span>';
                } else if (result.status === 'error') {
                    statusBadge = '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em;">ERROR</span>';
                }
                html += `<td>${statusBadge}${isBest ? ' ‚≠ê BEST' : ''}</td>`;
                
                // Parameters column
                const params = result.params || {};
                const paramPairs = Object.entries(params)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([key, value]) => {
                        let formattedValue = value;
                        if (typeof value === 'number') {
                            if (Number.isInteger(value)) {
                                formattedValue = value;
                            } else if (key.includes('pct') || key.includes('percent')) {
                                formattedValue = (value * 100).toFixed(2) + '%';
                            } else {
                                formattedValue = value.toFixed(4);
                            }
                        } else if (typeof value === 'boolean') {
                            formattedValue = value ? 'True' : 'False';
                        }
                        return `<span style="display: inline-block; margin: 2px 4px; padding: 2px 6px; background: #f0f0f0; border-radius: 3px; font-size: 0.9em;"><strong>${key}:</strong> ${formattedValue}</span>`;
                    });
                html += `<td style="max-width: 300px; word-wrap: break-word;">${paramPairs.join('') || '-'}</td>`;
                
                // Score column
                if (result.score !== null && result.score !== undefined) {
                    html += `<td style="font-weight: ${isBest ? 'bold' : 'normal'}">${result.score.toFixed(4)}</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                // Return %
                if (result.total_return_pct !== null && result.total_return_pct !== undefined) {
                    const returnClass = result.total_return_pct >= 0 ? 'positive' : 'negative';
                    html += `<td class="${returnClass}">${result.total_return_pct >= 0 ? '+' : ''}${result.total_return_pct.toFixed(2)}%</td>`;
                } else {
                    html += '<td style="color: #999;">Not Tested</td>';
                }
                
                // Trades
                if (result.completed_trades !== null && result.completed_trades !== undefined) {
                    html += `<td>${result.completed_trades}</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                // Win Rate
                if (result.win_rate !== null && result.win_rate !== undefined) {
                    html += `<td>${result.win_rate.toFixed(2)}%</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                // Max DD %
                if (result.max_drawdown_pct !== null && result.max_drawdown_pct !== undefined) {
                    html += `<td class="negative">${result.max_drawdown_pct.toFixed(2)}%</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                // Sharpe
                if (result.sharpe_ratio !== null && result.sharpe_ratio !== undefined) {
                    html += `<td>${result.sharpe_ratio.toFixed(2)}</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                // Failure Reason
                if (result.failure_reason) {
                    html += `<td style="color: #dc3545; font-size: 0.9em; max-width: 250px;">${result.failure_reason}</td>`;
                } else {
                    html += '<td style="color: #999;">-</td>';
                }
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            // Add summary
            const passedCount = results.filter(r => r.status === 'passed').length;
            const failedCount = results.filter(r => r.status === 'failed').length;
            const errorCount = results.filter(r => r.status === 'error').length;
            
            // Analyze failure reasons
            const failureReasons = {};
            results.filter(r => r.failure_reason).forEach(r => {
                const reason = r.failure_reason;
                failureReasons[reason] = (failureReasons[reason] || 0) + 1;
            });
            
            // Get most common failure reason
            const mostCommonFailure = Object.keys(failureReasons).length > 0 
                ? Object.entries(failureReasons).sort((a, b) => b[1] - a[1])[0]
                : null;
            
            html += `
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-top: 0;">Summary</h3>
                    <p><strong>Total Combinations:</strong> ${results.length}</p>
                    <p><strong>Passed:</strong> <span style="color: #28a745;">${passedCount}</span></p>
                    <p><strong>Failed (guardrails):</strong> <span style="color: #ffc107;">${failedCount}</span></p>
                    <p><strong>Errors:</strong> <span style="color: #dc3545;">${errorCount}</span></p>
                    ${sortedResults[0] && sortedResults[0].status === 'passed' ? `
                        <p><strong>Best Combination:</strong> #${sortedResults[0].combination_number} (Score: ${sortedResults[0].score.toFixed(4)})</p>
                    ` : ''}
                    ${failedCount > 0 && passedCount === 0 ? `
                        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                            <h4 style="margin-top: 0; color: #856404;">‚ö†Ô∏è All Combinations Failed</h4>
                            ${mostCommonFailure ? `
                                <p style="margin-bottom: 8px;"><strong>Most Common Reason:</strong> ${mostCommonFailure[0]} (${mostCommonFailure[1]} combinations)</p>
                            ` : ''}
                            <p style="margin-bottom: 8px;"><strong>Possible Solutions:</strong></p>
                            <ul style="margin-top: 8px; padding-left: 20px;">
                                <li><strong>Increase Training Period:</strong> More data = more trading opportunities</li>
                                <li><strong>Adjust Parameters:</strong> Current parameters may be too restrictive (e.g., min_ema_separation too high, take_profit too large)</li>
                                <li><strong>Lower Min Trades Guardrail:</strong> If training period is short, consider reducing minimum trades requirement (not recommended for production)</li>
                                <li><strong>Check Strategy Logic:</strong> Verify that the strategy can generate trades with the given parameters</li>
                            </ul>
                            <p style="margin-top: 8px; margin-bottom: 0; font-size: 0.9em; color: #856404;">
                                <strong>Note:</strong> The optimization guardrails require at least 5 completed trades, max drawdown < 50%, and no lottery trades (single trade > 50% of profit).
                            </p>
                        </div>
                    ` : ''}
                </div>
            `;
            
            modalContent.innerHTML = html;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Store modal reference for closing
            window.optimizationResultsModal = modal;
        }
        
        // Function to close optimization results modal
        function closeOptimizationResults() {
            if (window.optimizationResultsModal) {
                window.optimizationResultsModal.remove();
                window.optimizationResultsModal = null;
            }
        }
        
        // Close modal on outside click
        document.addEventListener('click', function(event) {
            if (window.optimizationResultsModal && event.target === window.optimizationResultsModal) {
                closeOptimizationResults();
            }
            if (window.historyDetailsModal && event.target === window.historyDetailsModal) {
                closeHistoryDetails();
            }
        });
        
        // ============================================================================
        // Tab switching functionality
        // ============================================================================
        
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            const selectedContent = document.getElementById(`tab-content-${tabName}`);
            const selectedBtn = document.getElementById(`tab-${tabName}`);
            
            if (selectedContent && selectedBtn) {
                selectedContent.classList.add('active');
                selectedContent.style.display = 'block';
                selectedBtn.classList.add('active');
            }
            
            // Load history if switching to history tab
            if (tabName === 'history') {
                loadHistory();
            }
            
            // Initialize sensitivity tab if switching to it
            if (tabName === 'sensitivity') {
                initializeSensitivityTab();
            }
        }
        
        // ============================================================================
        // History Tab Functions
        // ============================================================================
        
        // History management variables
        let currentHistoryPage = 0;
        const historyPageSize = 20;
        let historyTotal = 0;
        
        async function loadHistory(page = 0) {
            const loading = document.getElementById('historyLoading');
            const table = document.getElementById('historyTable');
            const empty = document.getElementById('historyEmpty');
            const pagination = document.getElementById('historyPagination');
            
            // Check if elements exist
            if (!loading || !table || !empty || !pagination) {
                console.error('History tab elements not found. Make sure the History tab HTML is present.');
                return;
            }
            
            loading.style.display = 'block';
            table.style.display = 'none';
            empty.style.display = 'none';
            pagination.style.display = 'none';
            
            try {
                const filters = {
                    limit: historyPageSize,
                    offset: page * historyPageSize
                };
                
                const symbol = document.getElementById('historySymbol').value.trim();
                if (symbol) filters.symbol = symbol.toUpperCase();
                
                const strategyType = document.getElementById('historyStrategyType').value;
                if (strategyType) filters.strategy_type = strategyType;
                
                const startDate = document.getElementById('historyStartDate').value;
                if (startDate) filters.start_date = new Date(startDate).toISOString();
                
                const endDate = document.getElementById('historyEndDate').value;
                if (endDate) {
                    const end = new Date(endDate);
                    end.setHours(23, 59, 59, 999);
                    filters.end_date = end.toISOString();
                }
                
                const queryParams = new URLSearchParams(filters).toString();
                const response = await authFetch(`/backtesting/walk-forward/history?${queryParams}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load history: ${response.statusText}`);
                }
                
                const data = await response.json();
                historyTotal = data.total || 0;
                currentHistoryPage = page;
                
                if (data.analyses && data.analyses.length > 0) {
                    displayHistoryTable(data.analyses);
                    updateHistoryPagination();
                } else {
                    loading.style.display = 'none';
                    empty.style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading history:', error);
                loading.style.display = 'none';
                empty.style.display = 'block';
                empty.innerHTML = `<p style="color: #dc3545;">Error loading history: ${error.message}</p>`;
            }
        }
        
        function displayHistoryTable(analyses) {
            const table = document.getElementById('historyTable');
            const loading = document.getElementById('historyLoading');
            const empty = document.getElementById('historyEmpty');
            
            loading.style.display = 'none';
            empty.style.display = 'none';
            table.style.display = 'block';
            
            let html = `
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Symbol</th>
                            <th>Strategy</th>
                            <th>Date Range</th>
                            <th>Return %</th>
                            <th>Consistency</th>
                            <th>Windows</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            analyses.forEach(analysis => {
                const startDate = new Date(analysis.overall_start_time).toLocaleDateString();
                const endDate = new Date(analysis.overall_end_time).toLocaleDateString();
                const createdDate = new Date(analysis.created_at).toLocaleString();
                const returnClass = analysis.total_return_pct >= 0 ? 'positive' : 'negative';
                const name = analysis.name || analysis.label || 'Unnamed Analysis';
                
                html += `
                    <tr>
                        <td><strong>${escapeHtml(name)}</strong></td>
                        <td>${escapeHtml(analysis.symbol)}</td>
                        <td>${escapeHtml(analysis.strategy_type)}</td>
                        <td>${startDate} - ${endDate}</td>
                        <td class="value ${returnClass}">${analysis.total_return_pct.toFixed(2)}%</td>
                        <td>${analysis.consistency_score ? analysis.consistency_score.toFixed(1) : 'N/A'}</td>
                        <td>${analysis.total_windows}</td>
                        <td>${createdDate}</td>
                        <td class="actions" style="white-space: nowrap;">
                            <button class="btn btn-primary btn-small" onclick="viewHistoryDetails('${analysis.id}')" title="View Details" style="padding: 6px 10px; min-width: 36px;">üëÅÔ∏è</button>
                            <button class="btn btn-secondary btn-small" onclick="reuseHistoryConfig('${analysis.id}')" title="Reuse Configuration" style="padding: 6px 10px; min-width: 36px; margin-left: 5px;">‚Üª</button>
                            <button class="btn btn-secondary btn-small" onclick="deleteHistoryAnalysis('${analysis.id}')" title="Delete Analysis" style="background: #dc3545; padding: 6px 10px; min-width: 36px; margin-left: 5px;">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            table.innerHTML = html;
        }
        
        function updateHistoryPagination() {
            const pagination = document.getElementById('historyPagination');
            const prevBtn = document.getElementById('historyPrevBtn');
            const nextBtn = document.getElementById('historyNextBtn');
            const pageInfo = document.getElementById('historyPageInfo');
            
            if (historyTotal === 0) {
                pagination.style.display = 'none';
                return;
            }
            
            pagination.style.display = 'block';
            const totalPages = Math.ceil(historyTotal / historyPageSize);
            const currentPage = currentHistoryPage + 1;
            
            pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${historyTotal} total)`;
            prevBtn.disabled = currentHistoryPage === 0;
            nextBtn.disabled = currentHistoryPage >= totalPages - 1;
        }
        
        function loadHistoryPage(direction) {
            if (direction === 'prev' && currentHistoryPage > 0) {
                loadHistory(currentHistoryPage - 1);
            } else if (direction === 'next') {
                const totalPages = Math.ceil(historyTotal / historyPageSize);
                if (currentHistoryPage < totalPages - 1) {
                    loadHistory(currentHistoryPage + 1);
                }
            }
        }
        
        async function viewHistoryDetails(analysisId) {
            try {
                const response = await authFetch(`/backtesting/walk-forward/history/${analysisId}`);
                if (!response.ok) {
                    throw new Error(`Failed to load details: ${response.statusText}`);
                }
                
                const analysis = await response.json();
                showHistoryDetailsModal(analysis);
            } catch (error) {
                console.error('Error loading details:', error);
                alert(`Error loading analysis details: ${error.message}`);
            }
        }
        
        function showHistoryDetailsModal(analysis) {
            // Remove existing modal if any
            if (window.historyDetailsModal) {
                window.historyDetailsModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.id = 'historyDetailsModal';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: white; border-radius: 12px; padding: 30px; max-width: 90%; max-height: 90vh; overflow-y: auto; position: relative;';
            
            const name = analysis.name || analysis.label || 'Unnamed Analysis';
            const startDate = new Date(analysis.overall_start_time).toLocaleString();
            const endDate = new Date(analysis.overall_end_time).toLocaleString();
            const createdDate = new Date(analysis.created_at).toLocaleString();
            
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">${escapeHtml(name)}</h2>
                    <button onclick="closeHistoryDetails()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
                </div>
                
                <div class="stats-grid" style="margin-bottom: 30px;">
                    <div class="stat-card">
                        <h3>Total Return</h3>
                        <div class="value ${analysis.total_return_pct >= 0 ? 'positive' : 'negative'}">${analysis.total_return_pct.toFixed(2)}%</div>
                    </div>
                    <div class="stat-card">
                        <h3>Consistency Score</h3>
                        <div class="value">${analysis.consistency_score ? analysis.consistency_score.toFixed(1) : 'N/A'}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Total Windows</h3>
                        <div class="value">${analysis.total_windows}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Total Trades</h3>
                        <div class="value">${analysis.total_trades || 0}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Avg Win Rate</h3>
                        <div class="value">${analysis.avg_win_rate ? analysis.avg_win_rate.toFixed(1) + '%' : 'N/A'}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Sharpe Ratio</h3>
                        <div class="value">${analysis.sharpe_ratio ? analysis.sharpe_ratio.toFixed(2) : 'N/A'}</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3>Configuration</h3>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.9em;">
                        <p><strong>Symbol:</strong> ${escapeHtml(analysis.symbol)}</p>
                        <p><strong>Strategy:</strong> ${escapeHtml(analysis.strategy_type)}</p>
                        <p><strong>Kline Interval:</strong> ${analysis.params && analysis.params.kline_interval ? escapeHtml(analysis.params.kline_interval) : 'N/A'}</p>
                        <p><strong>Date Range:</strong> ${startDate} - ${endDate}</p>
                        <p><strong>Training Period:</strong> ${analysis.training_period_days} days</p>
                        <p><strong>Test Period:</strong> ${analysis.test_period_days} days</p>
                        <p><strong>Step Size:</strong> ${analysis.step_size_days} days</p>
                        <p><strong>Window Type:</strong> ${escapeHtml(analysis.window_type)}</p>
                        <p><strong>Leverage:</strong> ${analysis.leverage || 'N/A'}</p>
                        ${analysis.fixed_amount ? `
                        <p><strong>Position Sizing:</strong> Fixed Amount</p>
                        <p><strong>Fixed Amount:</strong> ${analysis.fixed_amount.toFixed(2)} USDT per trade</p>
                        ` : `
                        <p><strong>Position Sizing:</strong> Risk per Trade</p>
                        <p><strong>Risk per Trade:</strong> ${analysis.risk_per_trade ? (analysis.risk_per_trade * 100).toFixed(2) + '%' : 'N/A'}</p>
                        `}
                        <p><strong>Initial Balance:</strong> ${analysis.initial_balance ? analysis.initial_balance.toFixed(2) + ' USDT' : 'N/A'}</p>
                        ${analysis.optimization_enabled ? `
                        <p><strong>Optimization:</strong> Enabled</p>
                        <p><strong>Optimization Method:</strong> ${escapeHtml(analysis.optimization_method || 'N/A')}</p>
                        <p><strong>Optimization Metric:</strong> ${escapeHtml(analysis.optimization_metric || 'N/A')}</p>
                        ` : '<p><strong>Optimization:</strong> Disabled</p>'}
                        <p><strong>Created:</strong> ${createdDate}</p>
                    </div>
                </div>
            `;
            
            // Add equity curve if available
            if (analysis.equity_curve && analysis.equity_curve.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3>Equity Curve</h3>
                        <div id="historyEquityCurve" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 8px; background: #fff;"></div>
                    </div>
                `;
            }
            
            // Add windows table if available
            if (analysis.windows && analysis.windows.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3>Window Breakdown</h3>
                        <div id="historyWindowsTable"></div>
                    </div>
                `;
            }
            
            html += `
                <div style="text-align: right; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeHistoryDetails()">Close</button>
                    <button class="btn btn-primary" onclick="reuseHistoryConfig('${analysis.id}')" style="margin-left: 10px;">Reuse Configuration</button>
                </div>
            `;
            
            modalContent.innerHTML = html;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            window.historyDetailsModal = modal;
            
            // Render equity curve if available
            if (analysis.equity_curve && analysis.equity_curve.length > 0) {
                console.log('Equity curve data received:', analysis.equity_curve.length, 'points');
                console.log('Sample equity curve point:', analysis.equity_curve[0]);
                setTimeout(() => {
                    renderHistoryEquityCurve(analysis.equity_curve, analysis.initial_balance);
                }, 100);
            } else {
                console.warn('No equity curve data available in analysis');
                // Show a message in the equity curve container
                const equityContainer = document.getElementById('historyEquityCurve');
                if (equityContainer) {
                    equityContainer.innerHTML = '<p style="color: #ffc107; padding: 20px; text-align: center;">' +
                        '<strong>No equity curve data available</strong><br>' +
                        '<small>This may occur if all parameter combinations failed guardrails or no trades were executed during the analysis.</small>' +
                        '</p>';
                }
            }
            
            // Render windows table if available
            if (analysis.windows && analysis.windows.length > 0) {
                renderHistoryWindowsTable(analysis.windows);
            }
        }
        
        function renderHistoryEquityCurve(equityCurve, initialBalance) {
            const container = document.getElementById('historyEquityCurve');
            if (!container) {
                console.error('Equity curve container not found');
                return;
            }
            
            // Handle empty or invalid equity curve gracefully
            if (!equityCurve || !Array.isArray(equityCurve) || equityCurve.length === 0) {
                console.warn('Empty or invalid equity curve data:', equityCurve);
                container.innerHTML = '<p style="color: #ffc107; padding: 20px; text-align: center;">' +
                    '<strong>No equity curve data available</strong><br>' +
                    '<small>This may occur if all parameter combinations failed guardrails or no trades were executed.</small>' +
                    '</p>';
                return;
            }
            
            // Filter out any null or invalid points before processing
            const validPoints = equityCurve.filter(point => 
                point && 
                typeof point === 'object' && 
                point.time !== null && 
                point.time !== undefined && 
                point.balance !== null && 
                point.balance !== undefined
            );
            
            if (validPoints.length === 0) {
                console.warn('All equity curve points are invalid:', equityCurve);
                container.innerHTML = '<p style="color: #ffc107; padding: 20px; text-align: center;">' +
                    '<strong>No valid equity curve data</strong><br>' +
                    '<small>All data points were invalid. This may occur if parameter combinations failed guardrails.</small>' +
                    '</p>';
                return;
            }
            
            // Use filtered valid points
            equityCurve = validPoints;
            
            console.log('Rendering equity curve with', equityCurve.length, 'points');
            console.log('First point:', equityCurve[0]);
            console.log('Last point:', equityCurve[equityCurve.length - 1]);
            
            try {
                const chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 400,
                    layout: {
                        background: { color: '#ffffff' },
                        textColor: '#333',
                    },
                    grid: {
                        vertLines: { color: '#e0e0e0' },
                        horzLines: { color: '#e0e0e0' },
                    },
                    timeScale: {
                        timeVisible: true,
                        secondsVisible: false,
                    },
                    crosshair: {
                        mode: 0, // Normal crosshair mode
                    },
                });
                
                const series = chart.addLineSeries({
                    color: '#667eea',
                    lineWidth: 2,
                    title: 'Balance',
                });
                
                // Convert equity curve data - handle both timestamp formats with null checks
                const data = equityCurve
                    .map(point => {
                        // Skip null or invalid points
                        if (!point || point.time === null || point.time === undefined || 
                            point.balance === null || point.balance === undefined) {
                            return null;
                        }
                        
                        let timeValue;
                        try {
                            if (typeof point.time === 'string') {
                                // ISO string format - convert to Unix timestamp (seconds)
                                const date = new Date(point.time);
                                if (isNaN(date.getTime())) {
                                    console.warn('Invalid date string:', point.time);
                                    return null;
                                }
                                timeValue = Math.floor(date.getTime() / 1000);
                            } else if (typeof point.time === 'number') {
                                // Already a timestamp - check if it's milliseconds or seconds
                                timeValue = point.time > 1e10 ? Math.floor(point.time / 1000) : point.time;
                            } else {
                                // Try to parse as date
                                const date = new Date(point.time);
                                if (isNaN(date.getTime())) {
                                    console.warn('Invalid date:', point.time);
                                    return null;
                                }
                                timeValue = Math.floor(date.getTime() / 1000);
                            }
                            
                            // Parse balance value
                            const balanceValue = typeof point.balance === 'number' 
                                ? point.balance 
                                : parseFloat(point.balance);
                            
                            // Validate values - allow balance to be 0 or positive, time must be positive
                            if (!isFinite(timeValue) || !isFinite(balanceValue) || balanceValue < 0 || timeValue <= 0) {
                                console.warn('Invalid data point:', point, 'timeValue:', timeValue, 'balanceValue:', balanceValue);
                                return null;
                            }
                            
                            return {
                                time: timeValue,
                                value: balanceValue,
                            };
                        } catch (error) {
                            console.warn('Error processing equity curve point:', point, error);
                            return null;
                        }
                    })
                    .filter(point => point !== null && point !== undefined);
                
                if (data.length === 0) {
                    container.innerHTML = '<p style="color: #dc3545; padding: 20px;">No valid equity curve data available</p>';
                    return;
                }
                
                // Sort data by time to ensure proper ordering
                data.sort((a, b) => a.time - b.time);
                
                // Final validation - remove any remaining null/undefined values
                const validData = data.filter(point => {
                    const isValid = point !== null && 
                                   point !== undefined && 
                                   point.time !== null && 
                                   point.time !== undefined && 
                                   point.value !== null && 
                                   point.value !== undefined &&
                                   isFinite(point.time) && 
                                   isFinite(point.value) &&
                                   point.time > 0 &&
                                   point.value >= 0;
                    if (!isValid) {
                        console.warn('Filtering out invalid data point:', point);
                    }
                    return isValid;
                });
                
                if (validData.length === 0) {
                    container.innerHTML = '<p style="color: #dc3545; padding: 20px;">No valid equity curve data available after filtering</p>';
                    return;
                }
                
                console.log(`Rendering equity curve with ${validData.length} valid points out of ${data.length} total`);
                
                // Final check - ensure no null/undefined values in the data
                // Convert to plain numbers and validate
                const finalData = validData
                    .map(point => {
                        // Ensure we have valid numbers
                        const timeNum = typeof point.time === 'number' ? point.time : Number(point.time);
                        const valueNum = typeof point.value === 'number' ? point.value : Number(point.value);
                        
                        // Return null if conversion failed
                        if (isNaN(timeNum) || isNaN(valueNum) || timeNum <= 0 || valueNum < 0) {
                            return null;
                        }
                        
                        return {
                            time: timeNum,
                            value: valueNum
                        };
                    })
                    .filter(point => point !== null && point !== undefined);
                
                if (finalData.length === 0) {
                    container.innerHTML = '<p style="color: #dc3545; padding: 20px;">No valid equity curve data available after final validation</p>';
                    return;
                }
                
                console.log(`Final data count: ${finalData.length} points`);
                
                // One more safety check - verify all points are valid before setting
                const safeData = finalData.filter(point => {
                    const isValid = point && 
                                   typeof point === 'object' &&
                                   'time' in point && 
                                   'value' in point &&
                                   typeof point.time === 'number' &&
                                   typeof point.value === 'number' &&
                                   !isNaN(point.time) &&
                                   !isNaN(point.value) &&
                                   isFinite(point.time) &&
                                   isFinite(point.value) &&
                                   point.time > 0 &&
                                   point.value >= 0;
                    if (!isValid) {
                        console.error('Found invalid point in final data:', point);
                    }
                    return isValid;
                });
                
                if (safeData.length === 0) {
                    container.innerHTML = '<p style="color: #dc3545; padding: 20px;">No valid equity curve data available after safety check</p>';
                    return;
                }
                
                console.log(`Safe data count: ${safeData.length} points (removed ${finalData.length - safeData.length} invalid points)`);
                
                // Final conversion - ensure all values are primitive numbers (not objects)
                const chartData = safeData.map(point => {
                    // Force conversion to primitive numbers
                    const time = +point.time;  // Unary plus ensures primitive number
                    const value = +point.value;  // Unary plus ensures primitive number
                    
                    // Final validation
                    if (!Number.isFinite(time) || !Number.isFinite(value) || time <= 0 || value < 0) {
                        console.error('Invalid chart data point after final conversion:', { time, value, original: point });
                        return null;
                    }
                    
                    return {
                        time: time,
                        value: value
                    };
                }).filter(p => p !== null);
                
                if (chartData.length === 0) {
                    container.innerHTML = '<p style="color: #dc3545; padding: 20px;">No valid chart data after final conversion</p>';
                    return;
                }
                
                console.log(`Chart data count: ${chartData.length} points`);
                console.log('Sample chart data point:', chartData[0]);
                
                // Set data to chart - only use chartData
                series.setData(chartData);
                
                // Add initial balance line
                if (initialBalance && chartData.length > 0 && isFinite(initialBalance) && initialBalance > 0) {
                    try {
                        const initialBalanceValue = Number(initialBalance);
                        if (!isNaN(initialBalanceValue) && initialBalanceValue > 0) {
                            const initialLine = chart.addLineSeries({
                                color: '#999',
                                lineWidth: 1,
                                lineStyle: 2, // Dashed
                                title: 'Initial Balance',
                            });
                            const initialLineData = [
                                { time: +chartData[0].time, value: initialBalanceValue },
                                { time: +chartData[chartData.length - 1].time, value: initialBalanceValue },
                            ];
                            // Validate initial line data
                            if (initialLineData.every(p => !isNaN(p.time) && !isNaN(p.value) && p.time > 0 && p.value > 0)) {
                                initialLine.setData(initialLineData);
                            } else {
                                console.warn('Invalid initial balance line data:', initialLineData);
                            }
                        }
                    } catch (lineError) {
                        console.warn('Error adding initial balance line:', lineError);
                    }
                }
                
                chart.timeScale().fitContent();
            } catch (error) {
                console.error('Error rendering equity curve:', error);
                container.innerHTML = '<p style="color: #dc3545; padding: 20px;">Error rendering equity curve</p>';
            }
        }
        
        function renderHistoryWindowsTable(windows) {
            const container = document.getElementById('historyWindowsTable');
            if (!container) return;
            
            // Store windows data globally for showOptimizationResults function
            window.historyWindowBreakdownData = windows;
            
            let html = `
                <table class="trades-table" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Window</th>
                            <th>Training Return</th>
                            <th>Test Return</th>
                            <th>Training Sharpe</th>
                            <th>Test Sharpe</th>
                            <th>Training Win Rate</th>
                            <th>Test Win Rate</th>
                            <th>Training Trades</th>
                            <th>Test Trades</th>
                            <th>Optimization Results</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            windows.forEach((window, index) => {
                html += `
                    <tr>
                        <td>${window.window_number || index + 1}</td>
                        <td class="${window.training_return_pct >= 0 ? 'positive' : 'negative'}">${window.training_return_pct !== null && window.training_return_pct !== undefined ? window.training_return_pct.toFixed(2) + '%' : 'N/A'}</td>
                        <td class="${window.test_return_pct >= 0 ? 'positive' : 'negative'}">${window.test_return_pct !== null && window.test_return_pct !== undefined ? window.test_return_pct.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${window.training_sharpe !== null && window.training_sharpe !== undefined ? window.training_sharpe.toFixed(2) : 'N/A'}</td>
                        <td>${window.test_sharpe !== null && window.test_sharpe !== undefined ? window.test_sharpe.toFixed(2) : 'N/A'}</td>
                        <td>${window.training_win_rate !== null && window.training_win_rate !== undefined ? window.training_win_rate.toFixed(1) + '%' : 'N/A'}</td>
                        <td>${window.test_win_rate !== null && window.test_win_rate !== undefined ? window.test_win_rate.toFixed(1) + '%' : 'N/A'}</td>
                        <td>${window.training_trades || 0}</td>
                        <td>${window.test_trades || 0}</td>
                        <td>
            `;
                
                // Add button to view optimization results if available
                if (window.optimization_results && Array.isArray(window.optimization_results) && window.optimization_results.length > 0) {
                    html += `<button onclick="showOptimizationResults(${window.window_number || index + 1})" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">View All Combinations (${window.optimization_results.length})</button>`;
                } else {
                    html += '<span style="color: #999;">-</span>';
                }
                
                html += `
                        </td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
        }
        
        function closeHistoryDetails() {
            if (window.historyDetailsModal) {
                window.historyDetailsModal.remove();
                window.historyDetailsModal = null;
            }
        }
        
        async function reuseHistoryConfig(analysisId) {
            try {
                const response = await authFetch(`/backtesting/walk-forward/history/${analysisId}/config`);
                if (!response.ok) {
                    throw new Error(`Failed to load config: ${response.statusText}`);
                }
                
                const config = await response.json();
                
                // Close history details modal if open
                closeHistoryDetails();
                
                // Switch to Run Analysis tab
                switchTab('run');
                
                // Pre-fill form with configuration
                if (config.symbol) document.getElementById('symbol').value = config.symbol;
                
                // Set strategy type first, which will trigger params update
                if (config.strategy_type) {
                    document.getElementById('strategyType').value = config.strategy_type;
                    // Trigger change event to update strategy params
                    const strategyTypeSelect = document.getElementById('strategyType');
                    if (strategyTypeSelect) {
                        strategyTypeSelect.dispatchEvent(new Event('change'));
                    }
                }
                
                // Set analysis type to walk-forward
                document.querySelector('input[name="analysisType"][value="walkforward"]').checked = true;
                handleAnalysisTypeChange();
                
                // Set walk-forward parameters
                if (config.training_period_days) document.getElementById('trainingPeriodDays').value = config.training_period_days;
                if (config.test_period_days) document.getElementById('testPeriodDays').value = config.test_period_days;
                if (config.step_size_days) document.getElementById('stepSizeDays').value = config.step_size_days;
                if (config.window_type) document.getElementById('windowType').value = config.window_type;
                
                // Set date range
                if (config.start_time) {
                    const startDate = new Date(config.start_time);
                    const localStart = new Date(startDate.getTime() - startDate.getTimezoneOffset() * 60000);
                    document.getElementById('startTime').value = localStart.toISOString().slice(0, 16);
                }
                if (config.end_time) {
                    const endDate = new Date(config.end_time);
                    const localEnd = new Date(endDate.getTime() - endDate.getTimezoneOffset() * 60000);
                    document.getElementById('endTime').value = localEnd.toISOString().slice(0, 16);
                }
                
                // Set other parameters
                if (config.leverage) document.getElementById('leverage').value = config.leverage;
                if (config.risk_per_trade) document.getElementById('riskPerTrade').value = config.risk_per_trade;
                if (config.initial_balance) document.getElementById('initialBalance').value = config.initial_balance;
                
                // Set strategy parameters
                if (config.params) {
                    Object.keys(config.params).forEach(key => {
                        const input = document.querySelector(`#strategyParams input[name="${key}"], #strategyParams select[name="${key}"], #strategyParams input[id="param_${key}"], #strategyParams select[id="param_${key}"]`);
                        if (input) {
                            if (input.type === 'checkbox') {
                                input.checked = config.params[key];
                            } else {
                                input.value = config.params[key];
                            }
                        }
                    });
                }
                
                // Set optimization parameters if available
                if (config.optimization_enabled && config.optimize_params && Object.keys(config.optimize_params).length > 0) {
                    const enableOptimizationCheckbox = document.getElementById('enableOptimization');
                    if (enableOptimizationCheckbox) {
                        enableOptimizationCheckbox.checked = true;
                        handleOptimizationToggle();
                    }
                    
                    // Wait for optimization params builder to be rendered
                    setTimeout(() => {
                        Object.keys(config.optimize_params).forEach(key => {
                            const input = document.getElementById(`opt_param_${key}`);
                            if (input) {
                                // Convert array to comma-separated string for text inputs
                                if (input.type === 'text') {
                                    const value = Array.isArray(config.optimize_params[key]) 
                                        ? config.optimize_params[key].join(',')
                                        : String(config.optimize_params[key]);
                                    input.value = value;
                                } else if (input.tagName === 'SELECT' && input.multiple) {
                                    // For select dropdowns, select the matching options
                                    const values = Array.isArray(config.optimize_params[key]) 
                                        ? config.optimize_params[key].map(v => String(v))
                                        : [String(config.optimize_params[key])];
                                    Array.from(input.options).forEach(option => {
                                        option.selected = values.includes(option.value);
                                    });
                                }
                            }
                        });
                    }, 300);
                    
                    // Set optimization method and metric
                    if (config.optimization_method) {
                        const methodSelect = document.getElementById('optimizationMethod');
                        if (methodSelect) methodSelect.value = config.optimization_method;
                    }
                    if (config.optimization_metric) {
                        const metricSelect = document.getElementById('optimizationMetric');
                        if (metricSelect) metricSelect.value = config.optimization_metric;
                    }
                    
                    // Set guardrails
                    if (config.min_trades_guardrail) {
                        const minTradesInput = document.getElementById('minTradesGuardrail');
                        if (minTradesInput) minTradesInput.value = config.min_trades_guardrail;
                    }
                    if (config.max_drawdown_cap) {
                        const maxDrawdownInput = document.getElementById('maxDrawdownCap');
                        if (maxDrawdownInput) maxDrawdownInput.value = config.max_drawdown_cap;
                    }
                    if (config.lottery_trade_threshold) {
                        const lotteryInput = document.getElementById('lotteryTradeThreshold');
                        if (lotteryInput) lotteryInput.value = config.lottery_trade_threshold;
                    }
                }
                
                alert('Configuration loaded! Review and modify as needed, then click "Run Analysis".');
            } catch (error) {
                console.error('Error loading config:', error);
                alert(`Error loading configuration: ${error.message}`);
            }
        }
        
        async function deleteHistoryAnalysis(analysisId) {
            if (!confirm('Are you sure you want to delete this analysis? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await authFetch(`/backtesting/walk-forward/history/${analysisId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to delete: ${response.statusText}`);
                }
                
                // Reload history
                loadHistory(currentHistoryPage);
                alert('Analysis deleted successfully.');
            } catch (error) {
                console.error('Error deleting analysis:', error);
                alert(`Error deleting analysis: ${error.message}`);
            }
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        // Window table sorting function
        function sortWindowTable(sortBy) {
            const container = document.getElementById('windowBreakdownTable');
            if (!container || !window.windowBreakdownData) return;
            
            const windows = [...window.windowBreakdownData];
            const bestWindow = windows.reduce((best, w) => w.test_return_pct > best.test_return_pct ? w : best, windows[0])?.window_number;
            const worstWindow = windows.reduce((worst, w) => w.test_return_pct < worst.test_return_pct ? w : worst, windows[0])?.window_number;
            
            // Sort based on criteria
            if (sortBy === 'return') {
                windows.sort((a, b) => b.test_return_pct - a.test_return_pct);
            } else if (sortBy === 'trades') {
                windows.sort((a, b) => (b.test_result?.total_trades || 0) - (a.test_result?.total_trades || 0));
            } else if (sortBy === 'window') {
                windows.sort((a, b) => a.window_number - b.window_number);
            }
            
            // Re-render with sorted data
            displayWindowBreakdown(windows, bestWindow, worstWindow);
        }

        // Initialize strategy type change handler - works whether DOM is ready or not
        function attachStrategyTypeHandler() {
            const strategyTypeSelect = document.getElementById('strategyType');
            if (strategyTypeSelect) {
                // Check if listener is already attached
                if (strategyTypeSelect.hasAttribute('data-listener-attached')) {
                    console.log('Backtesting: Strategy type handler already attached');
                    return true;
                }
                
                // Add event listener
                strategyTypeSelect.addEventListener('change', function(e) {
                    console.log('Strategy type changed to:', e.target.value);
                    updateStrategyParams();
                    // Rebuild optimization params builder if walk-forward is selected
                    const analysisType = document.querySelector('input[name="analysisType"]:checked')?.value;
                    if (analysisType === 'walkforward') {
                        buildOptimizationParamsBuilder();
                    }
                });
                strategyTypeSelect.setAttribute('data-listener-attached', 'true');
                console.log('Backtesting: Strategy type change handler attached');
                return true;
            } else {
                console.warn('Backtesting: Strategy type select element not found, will retry on DOMContentLoaded');
                return false;
            }
        }

        // Try to attach immediately if DOM is already ready
        if (document.readyState === 'loading') {
            // DOM is still loading, wait for DOMContentLoaded
            window.addEventListener('DOMContentLoaded', () => {
                attachStrategyTypeHandler();
                // If a strategy type is already selected, update params
                const strategyTypeSelect = document.getElementById('strategyType');
                if (strategyTypeSelect && strategyTypeSelect.value) {
                    console.log('Strategy type already selected on load:', strategyTypeSelect.value);
                    updateStrategyParams();
                }
            });
        } else {
            // DOM is already loaded, attach immediately
            attachStrategyTypeHandler();
            // If a strategy type is already selected, update params
            const strategyTypeSelect = document.getElementById('strategyType');
            if (strategyTypeSelect && strategyTypeSelect.value) {
                console.log('Strategy type already selected:', strategyTypeSelect.value);
                updateStrategyParams();
            }
        }

        // Handle window resize for chart
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(() => {
                if (chart) {
                    const chartContainer = document.getElementById('chartContainer');
                    if (chartContainer && chartContainer.clientWidth > 0) {
                        chart.applyOptions({ width: chartContainer.clientWidth });
                    }
                }
            }, 250);
        });

        // Load user info
        // loadUserInfo is now in common.js

        // Initialize form with default time (last 2 hours)
        window.addEventListener('load', async () => {
            // loadUserInfo is called automatically by common.js
            setTimePreset(2);
            
            // Ensure strategy type handler is attached (fallback)
            setTimeout(() => {
                attachStrategyTypeHandler();
            }, 100);
        });
        
        // ============================================================================
        // Sensitivity Analysis Functions
        // ============================================================================
        
        let sensitivityTaskId = null;
        let sensitivityEventSource = null;
        let currentSensitivityResult = null; // Store current sensitivity result for WFA integration
        
        function initializeSensitivityTab() {
            // Set default time (last 7 days)
            const endTime = new Date();
            const startTime = new Date();
            startTime.setDate(startTime.getDate() - 7);
            
            const startInput = document.getElementById('sensitivityStartTime');
            const endInput = document.getElementById('sensitivityEndTime');
            
            if (startInput && endInput) {
                startInput.value = formatDateTimeLocal(startTime);
                endInput.value = formatDateTimeLocal(endTime);
            }
            
            // Update params if strategy type is already selected
            const strategyType = document.getElementById('sensitivityStrategyType');
            if (strategyType && strategyType.value) {
                updateSensitivityParams();
            }
        }
        
        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        function updateSensitivityParams() {
            const strategyType = document.getElementById('sensitivityStrategyType')?.value;
            if (!strategyType) return;
            
            const baseParamsContainer = document.getElementById('sensitivityBaseParams');
            const analyzeParamsContainer = document.getElementById('sensitivityAnalyzeParams');
            
            if (!baseParamsContainer || !analyzeParamsContainer) return;
            
            const params = strategyParams[strategyType];
            if (!params) return;
            
            // Clear existing
            baseParamsContainer.innerHTML = '';
            analyzeParamsContainer.innerHTML = '';
            
            // Create base params inputs
            Object.entries(params).forEach(([key, config]) => {
                // Skip kline_interval - it's set at the top level (sensitivityKlineInterval)
                // and cannot be varied as a parameter since it requires different data fetches
                if (key === 'kline_interval') return;
                
                const baseGroup = document.createElement('div');
                baseGroup.className = 'form-group';
                
                const label = document.createElement('label');
                label.textContent = config.label || key;
                label.setAttribute('for', `sensitivityBase_${key}`);
                
                let input;
                if (config.type === 'select') {
                    input = document.createElement('select');
                    input.id = `sensitivityBase_${key}`;
                    config.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        if (opt === config.value) option.selected = true;
                        input.appendChild(option);
                    });
                } else if (config.type === 'checkbox') {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = `sensitivityBase_${key}`;
                    input.checked = config.value || false;
                } else {
                    input = document.createElement('input');
                    input.type = config.type || 'number';
                    input.id = `sensitivityBase_${key}`;
                    input.value = config.value || '';
                    if (config.min !== undefined) input.min = config.min;
                    if (config.max !== undefined) input.max = config.max;
                    if (config.step !== undefined) input.step = config.step;
                }
                
                baseGroup.appendChild(label);
                baseGroup.appendChild(input);
                if (config.help) {
                    const small = document.createElement('small');
                    small.textContent = config.help;
                    baseGroup.appendChild(small);
                }
                baseParamsContainer.appendChild(baseGroup);
                
                // Create analyze param checkbox and value input
                // Skip kline_interval - it cannot be analyzed as a parameter
                if (key === 'kline_interval') return;
                
                const analyzeGroup = document.createElement('div');
                analyzeGroup.style.cssText = 'display: flex; gap: 10px; align-items: center; margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px;';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `sensitivityAnalyze_${key}`;
                checkbox.name = `analyze_${key}`;
                
                const label2 = document.createElement('label');
                label2.textContent = config.label || key;
                label2.setAttribute('for', `sensitivityAnalyze_${key}`);
                label2.style.cssText = 'min-width: 150px; font-weight: 600;';
                
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.id = `sensitivityValues_${key}`;
                valueInput.placeholder = 'e.g., 5,8,10,12,15';
                valueInput.style.cssText = 'flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;';
                valueInput.disabled = true;
                
                checkbox.addEventListener('change', () => {
                    valueInput.disabled = !checkbox.checked;
                });
                
                analyzeGroup.appendChild(checkbox);
                analyzeGroup.appendChild(label2);
                analyzeGroup.appendChild(valueInput);
                analyzeParamsContainer.appendChild(analyzeGroup);
            });
        }
        
        async function runSensitivityAnalysis(event) {
            event.preventDefault();
            
            const form = event.target;
            const submitBtn = form.querySelector('button[type="submit"]');
            
            // Reset any previous state
            if (sensitivityEventSource) {
                sensitivityEventSource.close();
                sensitivityEventSource = null;
            }
            sensitivityTaskId = null;
            
            // Hide previous results
            document.getElementById('sensitivityResults').style.display = 'none';
            
            // Collect form data
            const strategyType = document.getElementById('sensitivityStrategyType').value;
            const baseParams = {};
            const analyzeParams = {};
            
            // Collect base params (skip kline_interval - it's set at top level)
            Object.keys(strategyParams[strategyType] || {}).forEach(key => {
                if (key === 'kline_interval') return; // Skip - set at top level
                
                const input = document.getElementById(`sensitivityBase_${key}`);
                if (input) {
                    if (input.type === 'checkbox') {
                        baseParams[key] = input.checked;
                    } else if (input.type === 'number') {
                        baseParams[key] = parseFloat(input.value) || input.value;
                    } else {
                        baseParams[key] = input.value;
                    }
                }
            });
            
            // Add kline_interval from top-level dropdown
            const klineIntervalSelect = document.getElementById('sensitivityKlineInterval');
            if (klineIntervalSelect) {
                baseParams['kline_interval'] = klineIntervalSelect.value;
            }
            
            // Collect analyze params
            Object.keys(strategyParams[strategyType] || {}).forEach(key => {
                const checkbox = document.getElementById(`sensitivityAnalyze_${key}`);
                const valueInput = document.getElementById(`sensitivityValues_${key}`);
                if (checkbox && checkbox.checked && valueInput && valueInput.value.trim()) {
                    // Parse comma-separated values
                    const values = valueInput.value.split(',').map(v => {
                        v = v.trim();
                        // Try to parse as number, otherwise keep as string
                        const num = parseFloat(v);
                        return isNaN(num) ? v : num;
                    });
                    analyzeParams[key] = values;
                }
            });
            
            if (Object.keys(analyzeParams).length === 0) {
                alert('Please select at least one parameter to analyze and provide test values.');
                return;
            }
            
            // Build request
            const request = {
                name: document.getElementById('sensitivityName').value || null,
                symbol: document.getElementById('sensitivitySymbol').value,
                strategy_type: strategyType,
                start_time: new Date(document.getElementById('sensitivityStartTime').value).toISOString(),
                end_time: new Date(document.getElementById('sensitivityEndTime').value).toISOString(),
                base_params: baseParams,
                analyze_params: analyzeParams,
                metric: document.getElementById('sensitivityMetric').value,
                kline_interval: document.getElementById('sensitivityKlineInterval').value,
                leverage: parseInt(document.getElementById('sensitivityLeverage').value),
                risk_per_trade: parseFloat(document.getElementById('sensitivityRiskPerTrade').value),
                fixed_amount: document.getElementById('sensitivityFixedAmount').value ? parseFloat(document.getElementById('sensitivityFixedAmount').value) : null,
                initial_balance: parseFloat(document.getElementById('sensitivityInitialBalance').value)
            };
            
            try {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Starting...';
                
                const response = await authFetch('/backtesting/sensitivity-analysis/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(request)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to start analysis');
                }
                
                const data = await response.json();
                sensitivityTaskId = data.task_id;
                
                // Show progress
                document.getElementById('sensitivityProgress').style.display = 'block';
                document.getElementById('sensitivityResults').style.display = 'none';
                
                // Start tracking progress
                trackSensitivityProgress(sensitivityTaskId);
                
            } catch (error) {
                console.error('Error starting sensitivity analysis:', error);
                alert('Failed to start analysis: ' + error.message);
                submitBtn.disabled = false;
                submitBtn.textContent = 'Run Sensitivity Analysis';
                sensitivityTaskId = null;
                
                // Hide progress section if it was shown
                document.getElementById('sensitivityProgress').style.display = 'none';
            }
        }
        
        function trackSensitivityProgress(taskId) {
            if (sensitivityEventSource) {
                sensitivityEventSource.close();
            }
            
            const progressBar = document.getElementById('sensitivityProgressFill');
            const progressText = document.getElementById('sensitivityProgressText');
            
            sensitivityEventSource = new EventSource(`/backtesting/sensitivity-analysis/progress/${taskId}`);
            
            sensitivityEventSource.onmessage = (event) => {
                try {
                    const progress = JSON.parse(event.data);
                    
                    progressBar.style.width = `${progress.progress_percent || 0}%`;
                    progressText.textContent = progress.message || `Progress: ${progress.progress_percent || 0}%`;
                    
                    if (progress.status === 'completed') {
                        sensitivityEventSource.close();
                        sensitivityEventSource = null;
                        loadSensitivityResult(taskId);
                    } else if (progress.status === 'error' || progress.status === 'cancelled') {
                        sensitivityEventSource.close();
                        sensitivityEventSource = null;
                        progressText.textContent = `Analysis ${progress.status}: ${progress.error || 'Cancelled'}`;
                        const cancelBtn = document.getElementById('sensitivityProgress')?.querySelector('button');
                        if (cancelBtn) cancelBtn.disabled = true;
                        
                        // Reset form state on error/cancellation
                        const submitBtn = document.getElementById('sensitivityForm')?.querySelector('button[type="submit"]');
                        if (submitBtn) {
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Run Sensitivity Analysis';
                        }
                        sensitivityTaskId = null;
                    }
                } catch (e) {
                    console.error('Error parsing progress:', e);
                }
            };
            
            sensitivityEventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                sensitivityEventSource.close();
                sensitivityEventSource = null;
            };
        }
        
        async function loadSensitivityResult(taskId) {
            try {
                const response = await authFetch(`/backtesting/sensitivity-analysis/result/${taskId}`);
                if (!response.ok) throw new Error('Failed to load result');
                
                const result = await response.json();
                displaySensitivityResults(result);
                
            } catch (error) {
                console.error('Error loading result:', error);
                alert('Failed to load results: ' + error.message);
                
                // Reset form state on error
                const submitBtn = document.getElementById('sensitivityForm')?.querySelector('button[type="submit"]');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Run Sensitivity Analysis';
                }
                sensitivityTaskId = null;
                document.getElementById('sensitivityProgress').style.display = 'none';
            }
        }
        
        function displaySensitivityResults(result) {
            const resultsContainer = document.getElementById('sensitivityResultsContent');
            const resultsSection = document.getElementById('sensitivityResults');
            
            // Store result globally for WFA integration
            currentSensitivityResult = result;
            
            // Hide progress
            document.getElementById('sensitivityProgress').style.display = 'none';
            resultsSection.style.display = 'block';
            
            // Reset form state - enable submit button and reset text
            const submitBtn = document.getElementById('sensitivityForm')?.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Run Sensitivity Analysis';
            }
            
            // Clear task ID to allow new analysis
            sensitivityTaskId = null;
            
            let html = `
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px;">
                    <h3 style="margin-top: 0;">Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div>
                            <strong>Most Sensitive:</strong> ${result.most_sensitive_param || 'N/A'}
                        </div>
                        <div>
                            <strong>Least Sensitive:</strong> ${result.least_sensitive_param || 'N/A'}
                        </div>
                        <div>
                            <strong>Symbol:</strong> ${result.symbol || 'N/A'}
                        </div>
                        <div>
                            <strong>Strategy:</strong> ${result.strategy_type || 'N/A'}
                        </div>
                    </div>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="margin-top: 0;">Parameter Results</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="background: #f8f9fa; border-bottom: 2px solid #ddd;">
                                <th style="padding: 12px; text-align: left;">Parameter</th>
                                <th style="padding: 12px; text-align: left;">Sensitivity Score</th>
                                <th style="padding: 12px; text-align: left;">Optimal Value</th>
                                <th style="padding: 12px; text-align: left;">Worst Value</th>
                                <th style="padding: 12px; text-align: left;">Impact Range</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort by sensitivity score (highest first)
            const sortedResults = [...(result.parameter_results || [])].sort((a, b) => 
                (b.sensitivity_score || 0) - (a.sensitivity_score || 0)
            );
            
            sortedResults.forEach(paramResult => {
                const score = paramResult.sensitivity_score || 0;
                const scoreColor = score > 0.7 ? '#dc3545' : score > 0.4 ? '#ffc107' : '#28a745';
                
                html += `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 12px;"><strong>${paramResult.parameter_name}</strong></td>
                        <td style="padding: 12px;">
                            <span style="color: ${scoreColor}; font-weight: bold;">${score.toFixed(4)}</span>
                        </td>
                        <td style="padding: 12px;">${formatValue(paramResult.optimal_value)}</td>
                        <td style="padding: 12px;">${formatValue(paramResult.worst_value)}</td>
                        <td style="padding: 12px;">
                            ${paramResult.impact_range_display || (paramResult.impact_range ? paramResult.impact_range.toFixed(4) : 'N/A')}
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <!-- Sensitivity Score Chart -->
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 20px;">
                    <h3 style="margin-top: 0;">Sensitivity Score Visualization</h3>
                    <div id="sensitivityScoreChart" style="width: 100%; height: 300px; margin-top: 15px;"></div>
                </div>
                
                <!-- Parameter Impact Charts -->
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 20px;">
                    <h3 style="margin-top: 0;">Parameter Impact Analysis</h3>
                    <p style="color: #666; margin-bottom: 15px;">Select a parameter to view how different values affect the metric:</p>
                    <select id="paramChartSelector" style="width: 100%; max-width: 400px; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="">Select a parameter...</option>
                        ${sortedResults.map((pr, idx) => 
                            `<option value="${idx}">${pr.parameter_name}</option>`
                        ).join('')}
                    </select>
                    <div id="paramImpactChart" style="width: 100%; height: 350px; margin-top: 15px; display: none;"></div>
                </div>
            `;
            
            if (result.recommended_params) {
                html += `
                    <div style="background: #d4edda; padding: 20px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #28a745;">
                        <h3 style="margin-top: 0; color: #155724;">Recommended Parameters</h3>
                        <p style="color: #155724; margin-bottom: 10px;">Based on sensitivity analysis, consider using these parameter values:</p>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            ${Object.entries(result.recommended_params).map(([key, value]) => 
                                `<span style="padding: 5px 10px; background: white; border-radius: 4px;"><strong>${key}:</strong> ${formatValue(value)}</span>`
                            ).join('')}
                        </div>
                        <button class="btn btn-primary" onclick="useSensitivityForWFA()" style="margin-top: 15px;">
                            Use for Walk-Forward Analysis
                        </button>
                    </div>
                `;
            }
            
            resultsContainer.innerHTML = html;
            
            // Render sensitivity score bar chart
            renderSensitivityScoreChart(sortedResults);
            
            // Setup parameter impact chart selector
            const paramSelector = document.getElementById('paramChartSelector');
            if (paramSelector) {
                paramSelector.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.value);
                    if (!isNaN(idx) && sortedResults[idx]) {
                        renderParameterImpactChart(sortedResults[idx], result.metric);
                    } else {
                        const chartDiv = document.getElementById('paramImpactChart');
                        if (chartDiv) {
                            chartDiv.style.display = 'none';
                        }
                    }
                });
            }
        }
        
        function renderSensitivityScoreChart(parameterResults) {
            const chartDiv = document.getElementById('sensitivityScoreChart');
            if (!chartDiv || !parameterResults || parameterResults.length === 0) return;
            
            // Sort by sensitivity score (descending)
            const sorted = [...parameterResults].sort((a, b) => 
                (b.sensitivity_score || 0) - (a.sensitivity_score || 0)
            );
            
            // Create bar chart using Canvas API
            const canvas = document.createElement('canvas');
            chartDiv.innerHTML = '';
            chartDiv.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const width = chartDiv.offsetWidth || 800;
            const height = 300;
            canvas.width = width;
            canvas.height = height;
            
            const barWidth = Math.max(30, (width - 100) / sorted.length - 10);
            const maxScore = Math.max(...sorted.map(p => p.sensitivity_score || 0), 1);
            const chartHeight = height - 80;
            const barSpacing = 10;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw bars
            sorted.forEach((param, idx) => {
                const score = param.sensitivity_score || 0;
                const barHeight = (score / maxScore) * chartHeight;
                const x = 50 + idx * (barWidth + barSpacing);
                const y = height - 50 - barHeight;
                
                // Color based on sensitivity
                let color = '#28a745'; // Green (low)
                if (score > 0.7) color = '#dc3545'; // Red (high)
                else if (score > 0.4) color = '#ffc107'; // Yellow (medium)
                
                // Draw bar
                ctx.fillStyle = color;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Draw label (rotated)
                ctx.save();
                ctx.translate(x + barWidth / 2, height - 25);
                ctx.rotate(-Math.PI / 4);
                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                const label = param.parameter_name.length > 15 
                    ? param.parameter_name.substring(0, 12) + '...' 
                    : param.parameter_name;
                ctx.fillText(label, 0, 0);
                ctx.restore();
                
                // Draw score on top of bar
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(score.toFixed(3), x + barWidth / 2, y - 5);
            });
            
            // Draw Y-axis
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 20);
            ctx.lineTo(40, height - 50);
            ctx.stroke();
            
            // Draw Y-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = (maxScore / 5) * i;
                const y = height - 50 - (i / 5) * chartHeight;
                ctx.fillText(value.toFixed(2), 38, y + 4);
            }
            
            // Draw title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Sensitivity Score', width / 2, 15);
        }
        
        function renderParameterImpactChart(paramResult, metric) {
            const chartDiv = document.getElementById('paramImpactChart');
            if (!chartDiv || !paramResult || !paramResult.results || paramResult.results.length === 0) {
                if (chartDiv) chartDiv.style.display = 'none';
                return;
            }
            
            chartDiv.style.display = 'block';
            
            // Extract data points
            const dataPoints = paramResult.results
                .filter(r => r.metric !== null && r.metric !== undefined && r.value !== null && r.value !== undefined)
                .map(r => ({
                    value: typeof r.value === 'number' ? r.value : parseFloat(r.value),
                    metric: typeof r.metric === 'number' ? r.metric : parseFloat(r.metric)
                }))
                .sort((a, b) => a.value - b.value);
            
            if (dataPoints.length === 0) {
                chartDiv.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No valid data points available for this parameter.</p>';
                return;
            }
            
            // Create line chart using Canvas API
            const canvas = document.createElement('canvas');
            chartDiv.innerHTML = '';
            chartDiv.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const width = chartDiv.offsetWidth || 800;
            const height = 350;
            canvas.width = width;
            canvas.height = height;
            
            const padding = { top: 40, right: 40, bottom: 60, left: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = Math.min(...dataPoints.map(d => d.value));
            const maxValue = Math.max(...dataPoints.map(d => d.value));
            const minMetric = Math.min(...dataPoints.map(d => d.metric));
            const maxMetric = Math.max(...dataPoints.map(d => d.metric));
            const valueRange = maxValue - minValue || 1;
            const metricRange = maxMetric - minMetric || 1;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (i / 5) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Draw line and points
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            dataPoints.forEach((point, idx) => {
                const x = padding.left + ((point.value - minValue) / valueRange) * chartWidth;
                const y = padding.top + chartHeight - ((point.metric - minMetric) / metricRange) * chartHeight;
                
                if (idx === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#667eea';
            dataPoints.forEach(point => {
                const x = padding.left + ((point.value - minValue) / valueRange) * chartWidth;
                const y = padding.top + chartHeight - ((point.metric - minMetric) / metricRange) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Highlight optimal value
            if (paramResult.optimal_value !== null && paramResult.optimal_value !== undefined) {
                const optValue = typeof paramResult.optimal_value === 'number' 
                    ? paramResult.optimal_value 
                    : parseFloat(paramResult.optimal_value);
                
                if (!isNaN(optValue) && optValue >= minValue && optValue <= maxValue) {
                    const optX = padding.left + ((optValue - minValue) / valueRange) * chartWidth;
                    const optPoint = dataPoints.find(p => Math.abs(p.value - optValue) < (valueRange / 100));
                    if (optPoint) {
                        const optY = padding.top + chartHeight - ((optPoint.metric - minMetric) / metricRange) * chartHeight;
                        
                        // Draw marker
                        ctx.fillStyle = '#28a745';
                        ctx.beginPath();
                        ctx.arc(optX, optY, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw label
                        ctx.fillStyle = '#28a745';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Optimal', optX, optY - 10);
                    }
                }
            }
            
            // Draw labels
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Parameter Value (${paramResult.parameter_name})`, width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(`Metric (${metric || 'Performance'})`, 0, 0);
            ctx.restore();
            
            // Draw Y-axis labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = minMetric + (metricRange / 5) * i;
                const y = padding.top + chartHeight - (i / 5) * chartHeight;
                ctx.fillText(value.toFixed(2), padding.left - 10, y + 4);
            }
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const value = minValue + (valueRange / 5) * i;
                const x = padding.left + (i / 5) * chartWidth;
                ctx.fillText(value.toFixed(2), x, height - padding.bottom + 20);
            }
        }
        
        function formatValue(value) {
            if (value === null || value === undefined) return 'N/A';
            if (typeof value === 'number') {
                return value % 1 === 0 ? value.toString() : value.toFixed(4);
            }
            return String(value);
        }
        
        async function cancelSensitivityAnalysis() {
            if (!sensitivityTaskId) return;
            
            if (!confirm('Are you sure you want to cancel this analysis?')) return;
            
            try {
                const response = await authFetch(`/backtesting/sensitivity-analysis/cancel/${sensitivityTaskId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    if (sensitivityEventSource) {
                        sensitivityEventSource.close();
                        sensitivityEventSource = null;
                    }
                    document.getElementById('sensitivityProgress').style.display = 'none';
                    
                    // Reset form state
                    const submitBtn = document.getElementById('sensitivityForm')?.querySelector('button[type="submit"]');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Run Sensitivity Analysis';
                    }
                    
                    sensitivityTaskId = null;
                    alert('Analysis cancelled');
                } else {
                    throw new Error('Failed to cancel');
                }
            } catch (error) {
                console.error('Error cancelling analysis:', error);
                alert('Failed to cancel analysis: ' + error.message);
                
                // Reset form state even on error
                const submitBtn = document.getElementById('sensitivityForm')?.querySelector('button[type="submit"]');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Run Sensitivity Analysis';
                }
                sensitivityTaskId = null;
            }
        }
        
        function useSensitivityForWFA() {
            if (!currentSensitivityResult || !currentSensitivityResult.recommended_params) {
                alert('No recommended parameters available. Please run a sensitivity analysis first.');
                return;
            }
            
            // Switch to Run Analysis tab
            switchTab('run');
            
            // Wait for tab switch animation
            setTimeout(() => {
                // Set analysis type to walk-forward
                const walkForwardRadio = document.querySelector('input[name="analysisType"][value="walkforward"]');
                if (walkForwardRadio) {
                    walkForwardRadio.checked = true;
                    handleAnalysisTypeChange();
                }
                
                // Pre-fill basic fields
                const symbolInput = document.getElementById('symbol');
                if (symbolInput && currentSensitivityResult.symbol) {
                    symbolInput.value = currentSensitivityResult.symbol;
                }
                
                const strategyTypeSelect = document.getElementById('strategyType');
                if (strategyTypeSelect && currentSensitivityResult.strategy_type) {
                    strategyTypeSelect.value = currentSensitivityResult.strategy_type;
                    updateStrategyParams(); // Trigger parameter builder update
                }
                
                // Pre-fill time range (from sensitivity analysis)
                if (currentSensitivityResult.start_time) {
                    const startTimeInput = document.getElementById('startTime');
                    if (startTimeInput) {
                        const startDate = new Date(currentSensitivityResult.start_time);
                        startTimeInput.value = startDate.toISOString().slice(0, 16);
                    }
                }
                
                if (currentSensitivityResult.end_time) {
                    const endTimeInput = document.getElementById('endTime');
                    if (endTimeInput) {
                        const endDate = new Date(currentSensitivityResult.end_time);
                        endTimeInput.value = endDate.toISOString().slice(0, 16);
                    }
                }
                
                // Pre-fill leverage, risk, balance if available
                if (currentSensitivityResult.leverage) {
                    const leverageInput = document.getElementById('leverage');
                    if (leverageInput) leverageInput.value = currentSensitivityResult.leverage;
                }
                
                if (currentSensitivityResult.risk_per_trade) {
                    const riskInput = document.getElementById('riskPerTrade');
                    if (riskInput) riskInput.value = currentSensitivityResult.risk_per_trade;
                }
                
                if (currentSensitivityResult.initial_balance) {
                    const balanceInput = document.getElementById('initialBalance');
                    if (balanceInput) balanceInput.value = currentSensitivityResult.initial_balance;
                }
                
                if (currentSensitivityResult.fixed_amount) {
                    const fixedAmountInput = document.getElementById('fixedAmount');
                    if (fixedAmountInput) fixedAmountInput.value = currentSensitivityResult.fixed_amount;
                }
                
                // Pre-fill base strategy parameters from recommended_params
                setTimeout(() => {
                    const recommended = currentSensitivityResult.recommended_params;
                    const strategyType = currentSensitivityResult.strategy_type;
                    
                    if (strategyType && strategyParams[strategyType]) {
                        // Pre-fill base parameters
                        for (const [key, value] of Object.entries(recommended)) {
                            if (key === 'kline_interval') continue; // Skip kline_interval
                            
                            const paramConfig = strategyParams[strategyType][key];
                            if (!paramConfig) continue;
                            
                            const baseInput = document.getElementById(`param_${key}`);
                            if (baseInput) {
                                if (paramConfig.type === 'checkbox') {
                                    baseInput.checked = value === true || value === 'true';
                                } else {
                                    baseInput.value = value;
                                }
                            }
                        }
                    }
                    
                    // Enable optimization and pre-fill optimization parameters
                    const enableOptimizationCheckbox = document.getElementById('enableOptimization');
                    if (enableOptimizationCheckbox) {
                        enableOptimizationCheckbox.checked = true;
                        handleOptimizationToggle();
                        
                        // Wait for optimization builder to render
                        setTimeout(() => {
                            // Pre-fill optimization params with ranges around optimal values
                            const paramResults = currentSensitivityResult.parameter_results || [];
                            
                            for (const paramResult of paramResults) {
                                const paramName = paramResult.parameter_name;
                                const optimalValue = paramResult.optimal_value;
                                const testedValues = paramResult.tested_values || [];
                                
                                if (!optimalValue || testedValues.length === 0) continue;
                                
                                const paramConfig = strategyParams[strategyType]?.[paramName];
                                if (!paramConfig || paramName === 'kline_interval') continue;
                                
                                const optInput = document.getElementById(`opt_param_${paramName}`);
                                if (!optInput) continue;
                                
                                // Create a range around optimal value
                                let optValues = [];
                                
                                if (paramConfig.type === 'checkbox') {
                                    // For boolean, use both true and false
                                    optValues = [true, false];
                                    const select = optInput;
                                    Array.from(select.options).forEach(opt => {
                                        if (opt.value === 'true' || opt.value === 'false') {
                                            opt.selected = true;
                                        }
                                    });
                                } else if (paramConfig.type === 'select') {
                                    // For select, use all tested values or a subset
                                    optValues = testedValues.slice(0, 5); // Limit to 5 values
                                    const select = optInput;
                                    Array.from(select.options).forEach(opt => {
                                        if (optValues.includes(opt.value)) {
                                            opt.selected = true;
                                        }
                                    });
                                } else {
                                    // For numeric, create a range around optimal
                                    const numOptimal = typeof optimalValue === 'number' ? optimalValue : parseFloat(optimalValue);
                                    if (!isNaN(numOptimal)) {
                                        // Use tested values if available, otherwise create range
                                        if (testedValues.length > 0) {
                                            optValues = testedValues;
                                        } else {
                                            // Create range: ¬±20% or ¬±2, whichever is larger
                                            const range = Math.max(Math.abs(numOptimal * 0.2), 2);
                                            const min = Math.max(numOptimal - range, paramConfig.min || 0);
                                            const max = Math.min(numOptimal + range, paramConfig.max || Infinity);
                                            // Generate 3-5 values
                                            const step = (max - min) / 4;
                                            optValues = [];
                                            for (let i = 0; i <= 4; i++) {
                                                const val = min + (step * i);
                                                if (paramConfig.type === 'number' && paramConfig.step) {
                                                    const rounded = Math.round(val / paramConfig.step) * paramConfig.step;
                                                    optValues.push(parseFloat(rounded.toFixed(4)));
                                                } else {
                                                    optValues.push(parseFloat(val.toFixed(4)));
                                                }
                                            }
                                        }
                                        optInput.value = optValues.join(', ');
                                    }
                                }
                            }
                            
                            // Scroll to optimization section
                            const optimizationSection = document.getElementById('optimizationConfig');
                            if (optimizationSection) {
                                optimizationSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                            
                            alert('Form pre-filled with recommended parameters from sensitivity analysis!\n\nReview the optimization parameters and adjust as needed before running the walk-forward analysis.');
                        }, 300);
                    }
                }, 200);
            }, 100);
        }
    </script>
</body>
</html>

