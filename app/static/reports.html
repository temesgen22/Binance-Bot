<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binance Bot - Trading Reports</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="/static/chart-utils.js"></script>
    <script src="/static/auth.js"></script>
    <script src="/static/settings.js"></script>
    <script src="/static/utils.js"></script>
    <link rel="stylesheet" href="/static/common.css">
    <script src="/static/common.js"></script>
    <style>
        /* Page-specific styles - common styles are in common.css */
        .container {
            max-width: 1600px; /* Override common.css for this page */
        }

        .filters {
            padding: 25px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .filters h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5em;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .filter-group input,
        .filter-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .overview-stats {
            padding: 25px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .overview-stats h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-card h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-card .value.positive {
            color: #28a745;
        }

        .stat-card .value.negative {
            color: #dc3545;
        }

        .content {
            padding: 25px;
        }

        .strategy-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
            transition: box-shadow 0.3s;
        }

        .strategy-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .strategy-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .strategy-header:hover {
            background: #e9ecef;
        }

        .strategy-info {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .strategy-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }

        .strategy-meta {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            font-size: 0.9em;
            color: #666;
        }

        .strategy-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-item-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-item-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
        }

        .stat-item-value.positive {
            color: #28a745;
        }

        .stat-item-value.negative {
            color: #dc3545;
        }

        .expand-icon {
            font-size: 1.5em;
            transition: transform 0.3s;
        }

        .strategy-card.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .strategy-details {
            display: none;
            padding: 20px;
            background: #f8f9fa;
        }

        .strategy-card.expanded .strategy-details {
            display: block;
        }

        .chart-container {
            width: 100%;
            height: 500px;
            margin: 20px 0;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: white;
            display: none;
        }

        .chart-container.visible {
            display: block;
        }

        .chart-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 15px 0;
            display: inline-block;
        }

        .chart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .chart-button:active {
            transform: translateY(0);
        }

        .chart-section {
            margin: 15px 0;
        }

        .ohlc-info-box {
            margin: 0 0 15px 0;
            padding: 8px 12px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .ohlc-content {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .ohlc-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 12px;
        }

        .ohlc-label {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 2px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .ohlc-value {
            color: #333;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .ohlc-value.high {
            color: #4caf50;
        }

        .ohlc-value.low {
            color: #f44336;
        }

        .ohlc-value.ema-fast {
            color: #2196F3;
        }

        .ohlc-value.ema-slow {
            color: #FF9800;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }

        .trades-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .trades-table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .trades-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.9em;
        }

        .trades-table tbody tr:hover {
            background: #f8f9fa;
        }

        .trades-table tbody tr:last-child td {
            border-bottom: none;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            display: inline-block;
        }

        .badge.success {
            background: #d4edda;
            color: #155724;
        }

        .badge.danger {
            background: #f8d7da;
            color: #721c24;
        }

        .badge.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .badge.warning {
            background: #fff3cd;
            color: #856404;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1em;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .positive {
            color: #28a745;
        }

        .negative {
            color: #dc3545;
        }

        .refresh-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .refresh-controls h2 {
            color: #333;
            font-size: 1.5em;
        }

        @media (max-width: 768px) {
            .filter-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .strategy-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .trades-table {
                font-size: 0.8em;
            }

            .trades-table th,
            .trades-table td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="menu-toggle" aria-label="Toggle menu" aria-expanded="false">‚ò∞</button>
            <h1>üìä Trading Reports</h1>
            <p>Comprehensive trading analysis with Binance trade parameters</p>
            <div class="nav-links">
                <a href="/">üìã Log Viewer</a>
                <a href="/trades">üíπ Trade & PnL Viewer</a>
                <a href="/strategies">üèÜ Strategy Performance</a>
                <a href="/market-analyzer">üìà Market Analyzer</a>
                <a href="/backtesting">üî¨ Strategy Backtesting</a>
                <a href="/test-accounts/">üîê Test Accounts</a>
                <a href="/register">üöÄ Register Strategy</a>
                <a href="/docs">üìñ API Docs</a>
                <span id="user-info"></span>
                <a href="/static/settings.html">‚öôÔ∏è Settings</a>
                <a href="#" onclick="logout(); return false;" class="logout-link">üö™ Logout</a>
            </div>
        </div>

        <div class="filters">
            <h2>Filters</h2>
            <div class="filter-grid">
                <div class="filter-group">
                    <label for="accountFilter">Binance Account</label>
                    <select id="accountFilter">
                        <option value="">All Accounts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="strategyIdFilter">Strategy ID</label>
                    <input type="text" id="strategyIdFilter" placeholder="Filter by strategy ID">
                </div>
                <div class="filter-group">
                    <label for="strategyNameFilter">Strategy Name</label>
                    <input type="text" id="strategyNameFilter" placeholder="Filter by strategy name">
                </div>
                <div class="filter-group">
                    <label for="symbolFilter">Symbol</label>
                    <input type="text" id="symbolFilter" placeholder="e.g., BTCUSDT">
                </div>
                <div class="filter-group">
                    <label for="startDateFilter">Start Date & Time</label>
                    <input type="datetime-local" id="startDateFilter" step="1">
                </div>
                <div class="filter-group">
                    <label for="endDateFilter">End Date & Time</label>
                    <input type="datetime-local" id="endDateFilter" step="1">
                </div>
            </div>
            <div class="filter-actions">
                <button class="btn btn-primary" onclick="loadReport()">Generate Report</button>
                <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
            </div>
        </div>

        <div class="overview-stats" id="overviewStats" style="display: none;">
            <h2>Overall Statistics</h2>
            <div class="stats-grid" id="overviewStatsGrid">
                <!-- Stats will be populated here -->
            </div>
        </div>

        <div class="content">
            <div id="reportContent">
                <div class="loading">Click "Generate Report" to view trading reports</div>
            </div>
        </div>
    </div>

    <script>
        // Check authentication IMMEDIATELY - before any other code runs
        (function() {
            if (!requireAuth()) {
                // Stop execution - page will redirect
                throw new Error('Not authenticated');
            }
        })();

        // Load user info
        // loadUserInfo is now in common.js

        // Logout function is now global from auth.js

        let availableAccounts = {};

        async function loadAccounts() {
            try {
                const response = await authFetch('/accounts/list');
                if (!response.ok) throw new Error('Failed to load accounts');
                availableAccounts = await response.json();
                
                const select = document.getElementById('accountFilter');
                select.innerHTML = '<option value="">All Accounts</option>';
                for (const accountId in availableAccounts) {
                    if (Object.prototype.hasOwnProperty.call(availableAccounts, accountId)) {
                        const accountInfo = availableAccounts[accountId];
                        const option = document.createElement('option');
                        option.value = accountId;
                        const testnetLabel = accountInfo.testnet === 'True' || accountInfo.testnet === true ? ' [TESTNET]' : '';
                        option.textContent = `${accountInfo.name} (${accountId})${testnetLabel}`;
                        select.appendChild(option);
                    }
                }
            } catch (error) {
                console.error('Error loading accounts:', error);
            }
        }

        // formatCurrency is now in utils.js

        // formatPercent is now in utils.js

        function formatDate(dateString) {
            // Use UserSettings if available, otherwise fallback to UTC format
            if (typeof UserSettings !== 'undefined') {
                return UserSettings.formatDate(dateString);
            }
            // Fallback for when settings.js is not loaded
            if (!dateString) return 'N/A';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                    console.warn('Invalid date string:', dateString);
                    return 'Invalid Date';
                }
                const year = date.getUTCFullYear();
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const day = String(date.getUTCDate()).padStart(2, '0');
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
            } catch (e) {
                console.warn('Error formatting date:', dateString, e);
                return 'Invalid Date';
            }
        }

        function getFilters() {
            const accountId = document.getElementById('accountFilter').value;
            const strategyId = document.getElementById('strategyIdFilter').value.trim();
            const strategyName = document.getElementById('strategyNameFilter').value.trim();
            const symbol = document.getElementById('symbolFilter').value.trim();
            const startDate = document.getElementById('startDateFilter').value;
            const endDate = document.getElementById('endDateFilter').value;

            const params = new URLSearchParams();
            if (accountId) params.append('account_id', accountId);
            if (strategyId) params.append('strategy_id', strategyId);
            if (strategyName) params.append('strategy_name', strategyName);
            if (symbol) params.append('symbol', symbol.toUpperCase());
            if (startDate) {
                try {
                    // datetime-local input provides local time string (e.g., "2024-01-15T14:30")
                    // new Date() interprets this as LOCAL time, then toISOString() converts to UTC
                    // This ensures the backend receives UTC timestamps matching what Binance expects
                    const localDate = new Date(startDate);
                    if (!isNaN(localDate.getTime())) {
                        const isoStart = localDate.toISOString(); // Converts local time to UTC ISO string
                        params.append('start_date', isoStart);
                    } else {
                        console.warn('Invalid start date:', startDate);
                    }
                } catch (e) {
                    console.warn('Error converting start date:', e);
                }
            }
            if (endDate) {
                try {
                    // datetime-local input provides local time string (e.g., "2024-01-15T14:30")
                    // new Date() interprets this as LOCAL time, then toISOString() converts to UTC
                    // This ensures the backend receives UTC timestamps matching what Binance expects
                    const localDate = new Date(endDate);
                    if (!isNaN(localDate.getTime())) {
                        const isoEnd = localDate.toISOString(); // Converts local time to UTC ISO string
                        params.append('end_date', isoEnd);
                    } else {
                        console.warn('Invalid end date:', endDate);
                    }
                } catch (e) {
                    console.warn('Error converting end date:', e);
                }
            }

            return params.toString();
        }

        async function loadReport() {
            const content = document.getElementById('reportContent');
            content.innerHTML = '<div class="loading">Loading report...</div>';

            try {
                const filters = getFilters();
                const url = filters ? `/reports/?${filters}` : '/reports/';

                const response = await authFetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error (${response.status}): ${response.statusText}`);
                }

                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    throw new Error(`Expected JSON but received ${contentType}`);
                }

                const report = await response.json();
                console.log('Reports: Received report data:', report);
                console.log('Reports: Number of strategies:', report.strategies?.length || 0);
                if (report.strategies) {
                    report.strategies.forEach((strategy, idx) => {
                        console.log(`Reports: Strategy ${idx} (${strategy.strategy_id}): ${strategy.trades?.length || 0} trades`);
                        if (strategy.trades && strategy.trades.length > 0) {
                            console.log('Reports: First trade:', strategy.trades[0]);
                        }
                    });
                }
                displayReport(report);
            } catch (error) {
                console.error('Error loading report:', error);
                content.innerHTML = `<div class="error">Error loading report: ${error.message}</div>`;
            }
        }

        function displayReport(report) {
            // Display overview stats
            displayOverviewStats(report);

            // Display strategies
            const content = document.getElementById('reportContent');
            
            if (!report.strategies || report.strategies.length === 0) {
                content.innerHTML = '<div class="empty-state"><h3>No strategies found</h3><p>Try adjusting your filters</p></div>';
                return;
            }

            let html = '';
            report.strategies.forEach((strategy, index) => {
                html += createStrategyCard(strategy, index);
            });

            content.innerHTML = html;

            // Store report data for chart rendering
            window.currentReport = report;
            
            // Attach click handlers for expanding/collapsing
            document.querySelectorAll('.strategy-header').forEach(header => {
                header.addEventListener('click', function() {
                    const card = this.parentElement;
                    card.classList.toggle('expanded');
                });
            });
        }

        function displayOverviewStats(report) {
            const overviewStats = document.getElementById('overviewStats');
            const statsGrid = document.getElementById('overviewStatsGrid');
            
            overviewStats.style.display = 'block';
            
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>Total Strategies</h3>
                    <div class="value">${report.total_strategies || 0}</div>
                </div>
                <div class="stat-card">
                    <h3>Total Trades</h3>
                    <div class="value">${report.total_trades || 0}</div>
                </div>
                <div class="stat-card">
                    <h3>Overall Win Rate</h3>
                    <div class="value">${(report.overall_win_rate || 0).toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Overall Net PnL</h3>
                    <div class="value ${report.overall_net_pnl >= 0 ? 'positive' : 'negative'}">
                        ${formatCurrency(report.overall_net_pnl || 0)}
                    </div>
                </div>
            `;
        }

        function createStrategyCard(strategy, index) {
            const statusBadge = strategy.stopped_at 
                ? `<span class="badge warning">Stopped</span>`
                : `<span class="badge success">Running</span>`;

            const netPnlClass = strategy.net_pnl >= 0 ? 'positive' : 'negative';
            const winRateColor = strategy.win_rate >= 50 ? 'positive' : 'negative';

            return `
                <div class="strategy-card" id="strategy-${index}">
                    <div class="strategy-header">
                        <div class="strategy-info">
                            <div class="strategy-name">${strategy.strategy_name || strategy.strategy_id}</div>
                            <div class="strategy-meta">
                                <span><strong>Symbol:</strong> ${strategy.symbol}</span>
                                <span><strong>ID:</strong> ${strategy.strategy_id}</span>
                                ${statusBadge}
                            </div>
                        </div>
                        <div class="strategy-stats">
                            <div class="stat-item">
                                <div class="stat-item-label">Win Rate</div>
                                <div class="stat-item-value ${winRateColor}">${strategy.win_rate.toFixed(2)}%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-item-label">Net PnL</div>
                                <div class="stat-item-value ${netPnlClass}">${formatCurrency(strategy.net_pnl)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-item-label">Total Fee</div>
                                <div class="stat-item-value">${formatCurrency(strategy.total_fee || 0)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-item-label">Total Funding Fee</div>
                                <div class="stat-item-value">${formatCurrency(strategy.total_funding_fee || 0)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-item-label">Total Trades</div>
                                <div class="stat-item-value">${strategy.total_trades}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-item-label">Wins / Losses</div>
                                <div class="stat-item-value">
                                    <span class="positive">${strategy.wins}W</span> / 
                                    <span class="negative">${strategy.losses}L</span>
                                </div>
                            </div>
                        </div>
                        <div class="expand-icon">‚ñº</div>
                    </div>
                    <div class="strategy-details">
                        <div style="margin-bottom: 15px;">
                            <strong>Created:</strong> ${formatDate(strategy.created_at)} | 
                            <strong>Stopped:</strong> ${strategy.stopped_at ? formatDate(strategy.stopped_at) : 'Running'}
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>Total Profit:</strong> <span class="positive">${formatCurrency(strategy.total_profit_usd)}</span> | 
                            <strong>Total Loss:</strong> <span class="negative">${formatCurrency(strategy.total_loss_usd)}</span>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>Total Trading Fee:</strong> ${formatCurrency(strategy.total_fee || 0)} | 
                            <strong>Total Funding Fee:</strong> ${formatCurrency(strategy.total_funding_fee || 0)}
                        </div>
                        ${strategy.klines && strategy.klines.length > 0 ? `
                            <div class="chart-section">
                                <button class="chart-button" onclick="toggleChart(${index})" id="chart-button-${index}">
                                    üìà Show Chart
                                </button>
                                <div id="indicatorControls-${index}" style="display: none; margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                    <h4 style="margin-bottom: 10px; font-size: 1.1em;">Indicator Controls</h4>
                                    <div id="indicatorToggles-${index}" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                                </div>
                                <div id="chart-${index}" class="chart-container"></div>
                            </div>
                        ` : '<p style="color: #666; margin: 15px 0;">No chart data available for this strategy.</p>'}
                        ${strategy.trades && strategy.trades.length > 0 ? `
                            <h3 style="margin-top: 30px; margin-bottom: 10px;">Trade History</h3>
                            <div id="ohlc-info-${index}" class="ohlc-info-box" style="display: none;">
                                <div class="ohlc-content">
                                    <div class="ohlc-item">
                                        <span class="ohlc-label">Open</span>
                                        <span class="ohlc-value" id="ohlc-open-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item">
                                        <span class="ohlc-label">High</span>
                                        <span class="ohlc-value high" id="ohlc-high-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item">
                                        <span class="ohlc-label">Low</span>
                                        <span class="ohlc-value low" id="ohlc-low-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item">
                                        <span class="ohlc-label">Close</span>
                                        <span class="ohlc-value" id="ohlc-close-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item">
                                        <span class="ohlc-label">Change</span>
                                        <span class="ohlc-value" id="ohlc-change-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item" id="ohlc-ema-fast-item-${index}" style="display: none;">
                                        <span class="ohlc-label" id="ohlc-ema-fast-label-${index}">EMA</span>
                                        <span class="ohlc-value ema-fast" id="ohlc-ema-fast-${index}">-</span>
                                    </div>
                                    <div class="ohlc-item" id="ohlc-ema-slow-item-${index}" style="display: none;">
                                        <span class="ohlc-label" id="ohlc-ema-slow-label-${index}">EMA</span>
                                        <span class="ohlc-value ema-slow" id="ohlc-ema-slow-${index}">-</span>
                                    </div>
                                </div>
                            </div>
                            ${createTradesTable(strategy.trades)}
                        ` : '<p>No completed trades yet.</p>'}
                    </div>
                </div>
            `;
        }

        function createTradesTable(trades) {
            let html = '<table class="trades-table"><thead><tr>';
            html += '<th>Trade ID</th><th>Symbol</th><th>Side</th><th>Entry Time</th><th>Entry Price</th>';
            html += '<th>Exit Time</th><th>Exit Price</th><th>Quantity</th><th>Leverage</th>';
            html += '<th>Fee Paid</th><th>Funding Fee</th><th>Initial Margin</th><th>Margin Type</th><th>Notional Value</th>';
            html += '<th>PnL (USD)</th><th>PnL (%)</th><th>Exit Reason</th>';
            html += '</tr></thead><tbody>';

            trades.forEach(trade => {
                const pnlClass = trade.pnl_usd >= 0 ? 'positive' : 'negative';
                html += '<tr>';
                html += `<td>${trade.trade_id}</td>`;
                html += `<td><strong>${trade.symbol}</strong></td>`;
                html += `<td><span class="badge ${trade.side === 'LONG' ? 'success' : 'danger'}">${trade.side}</span></td>`;
                html += `<td>${formatDate(trade.entry_time)}</td>`;
                html += `<td>$${trade.entry_price.toFixed(4)}</td>`;
                html += `<td>${formatDate(trade.exit_time)}</td>`;
                html += `<td>$${(trade.exit_price || 0).toFixed(4)}</td>`;
                html += `<td>${trade.quantity.toFixed(4)}</td>`;
                html += `<td>${trade.leverage}x</td>`;
                html += `<td>$${trade.fee_paid.toFixed(4)}</td>`;
                html += `<td>$${(trade.funding_fee || 0).toFixed(4)}</td>`;
                html += `<td>${trade.initial_margin ? '$' + trade.initial_margin.toFixed(2) : 'N/A'}</td>`;
                html += `<td>${trade.margin_type ? `<span class="badge info">${trade.margin_type}</span>` : 'N/A'}</td>`;
                html += `<td>${trade.notional_value ? '$' + trade.notional_value.toFixed(2) : 'N/A'}</td>`;
                html += `<td class="${pnlClass}"><strong>${formatCurrency(trade.pnl_usd)}</strong></td>`;
                html += `<td class="${pnlClass}"><strong>${formatPercent(trade.pnl_pct)}</strong></td>`;
                html += `<td>${trade.exit_reason || 'N/A'}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        function clearFilters() {
            document.getElementById('accountFilter').value = '';
            document.getElementById('strategyIdFilter').value = '';
            document.getElementById('strategyNameFilter').value = '';
            document.getElementById('symbolFilter').value = '';
            document.getElementById('startDateFilter').value = '';
            document.getElementById('endDateFilter').value = '';
        }

        // Chart rendering function
        const charts = {}; // Store chart instances by strategy index
        const chartVisibility = {}; // Track chart visibility state
        const candlestickSeries = {}; // Store candlestick series by strategy index
        const indicatorSeries = {}; // Store indicator series by strategy index for toggle control
        const indicatorToggles = {}; // Store toggle states by strategy index
        
        // Initialize chart renderer with reports-specific options
        const chartRenderer = new ChartRenderer({
            defaultHeight: 500,
            secondsVisible: false, // Reports don't need second precision
            supportRangeMeanReversion: true, // Enable range mean reversion support
        });
        
        // Single resize handler for all charts
        let resizeHandler = null;
        function setupChartResizeHandler() {
            if (resizeHandler) return; // Already set up
            resizeHandler = () => {
                Object.keys(charts).forEach(idx => {
                    const chart = charts[idx];
                    if (chart) {
                        const container = document.getElementById(`chart-${idx}`);
                        if (container) {
                            chart.applyOptions({ width: container.clientWidth });
                        }
                    }
                });
            };
            window.addEventListener('resize', resizeHandler);
        }
        setupChartResizeHandler();

        function toggleChart(index) {
            const chartContainer = document.getElementById(`chart-${index}`);
            const chartButton = document.getElementById(`chart-button-${index}`);
            
            if (!chartContainer) return;
            
            // Toggle visibility
            const isVisible = chartContainer.classList.contains('visible');
            
            if (!isVisible) {
                // Show chart
                chartContainer.classList.add('visible');
                chartButton.textContent = 'üìâ Hide Chart';
                
                // Render chart if not already rendered
                if (!charts[index]) {
                    const strategy = window.currentReport?.strategies[index];
                    if (strategy && strategy.klines && strategy.klines.length > 0) {
                        renderChart(strategy, index);
                    }
                }
            } else {
                // Hide chart
                chartContainer.classList.remove('visible');
                chartButton.textContent = 'üìà Show Chart';
            }
        }

        function createIndicatorToggles(strategy, index) {
            const controlsDiv = document.getElementById(`indicatorControls-${index}`);
            const togglesDiv = document.getElementById(`indicatorToggles-${index}`);
            
            if (!controlsDiv || !togglesDiv) return;
            
            const strategyType = strategy.strategy_type || '';
            const isRangeMeanReversion = strategyType === 'range_mean_reversion' && 
                                        strategy.indicators && 
                                        strategy.indicators.range_high;
            const hasEMAs = strategy.indicators && strategy.indicators.ema_fast && strategy.indicators.ema_slow;
            
            // Only show controls if there are indicators to toggle
            if (!isRangeMeanReversion && !hasEMAs) {
                controlsDiv.style.display = 'none';
                return;
            }
            
            controlsDiv.style.display = 'block';
            
            // Initialize toggle states for this chart
            indicatorToggles[index] = {
                rangeLines: true,
                entryZones: true,
                tpSlLevels: true,
                rsi: true,
                emaLines: true,
                emaSpread: false
            };
            
            // Build toggle HTML based on available indicators
            let togglesHTML = '';
            
            if (isRangeMeanReversion) {
                // Range mean reversion has all indicators
                togglesHTML = `
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-range-lines-${index}" checked>
                        <span>Range Lines (High/Mid/Low)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-entry-zones-${index}" checked>
                        <span>Entry Zones (Buy/Sell)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-tp-sl-${index}" checked>
                        <span>TP/SL Levels</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-rsi-${index}" checked>
                        <span>RSI Panel</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-ema-lines-${index}" checked>
                        <span>EMA Lines</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-ema-spread-${index}">
                        <span>EMA Spread</span>
                    </label>
                `;
            } else if (hasEMAs) {
                // Scalping only has EMA lines
                togglesHTML = `
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="toggle-ema-lines-${index}" checked>
                        <span>EMA Lines</span>
                    </label>
                `;
            }
            
            togglesDiv.innerHTML = togglesHTML;
            
            // Add event listeners based on available toggles
            if (isRangeMeanReversion) {
                document.getElementById(`toggle-range-lines-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].rangeLines = e.target.checked;
                    updateIndicatorVisibility(index);
                });
                document.getElementById(`toggle-entry-zones-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].entryZones = e.target.checked;
                    updateIndicatorVisibility(index);
                });
                document.getElementById(`toggle-tp-sl-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].tpSlLevels = e.target.checked;
                    updateIndicatorVisibility(index);
                });
                document.getElementById(`toggle-rsi-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].rsi = e.target.checked;
                    updateIndicatorVisibility(index);
                });
                document.getElementById(`toggle-ema-lines-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].emaLines = e.target.checked;
                    updateIndicatorVisibility(index);
                });
                document.getElementById(`toggle-ema-spread-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].emaSpread = e.target.checked;
                    updateIndicatorVisibility(index);
                });
            } else if (hasEMAs) {
                document.getElementById(`toggle-ema-lines-${index}`).addEventListener('change', (e) => {
                    indicatorToggles[index].emaLines = e.target.checked;
                    updateIndicatorVisibility(index);
                });
            }
        }

        function updateIndicatorVisibility(index) {
            if (!indicatorSeries[index] || !indicatorToggles[index]) return;
            
            const series = indicatorSeries[index];
            const toggles = indicatorToggles[index];
            const chart = charts[index];
            const candlestickSeriesInstance = candlestickSeries[index];
            
            if (!chart || !candlestickSeriesInstance) {
                console.warn(`Chart or candlestick series not found for index ${index}`);
                return;
            }
            
            // Update visibility of indicator series based on toggle states
            if (series.rangeHigh) {
                series.rangeHigh.applyOptions({ visible: toggles.rangeLines });
            }
            if (series.rangeMid) {
                series.rangeMid.applyOptions({ visible: toggles.rangeLines });
            }
            if (series.rangeLow) {
                series.rangeLow.applyOptions({ visible: toggles.rangeLines });
            }
            if (series.buyZoneUpper) {
                series.buyZoneUpper.applyOptions({ visible: toggles.entryZones });
            }
            if (series.sellZoneLower) {
                series.sellZoneLower.applyOptions({ visible: toggles.entryZones });
            }
            
            // Handle TP/SL price lines (remove all and recreate if enabled)
            if (series.tpSlPriceLines && series.tpSlPriceLines.length > 0) {
                // Remove all existing TP/SL price lines
                series.tpSlPriceLines.forEach(priceLine => {
                    try {
                        candlestickSeriesInstance.removePriceLine(priceLine);
                    } catch (e) {
                        // Price line might already be removed
                        console.warn('Error removing price line:', e);
                    }
                });
                series.tpSlPriceLines = [];
            }
            
            // Recreate TP/SL price lines if toggle is enabled
            if (toggles.tpSlLevels && series.tpSlData && candlestickSeriesInstance) {
                series.tpSlPriceLines = [];
                series.tpSlData.forEach(level => {
                    if (level.tp1 !== null && level.tp1 !== undefined) {
                        const tp1Line = candlestickSeriesInstance.createPriceLine({
                            price: level.tp1,
                            color: '#2196F3',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP1',
                        });
                        series.tpSlPriceLines.push(tp1Line);
                    }
                    if (level.tp2 !== null && level.tp2 !== undefined) {
                        const tp2Line = candlestickSeriesInstance.createPriceLine({
                            price: level.tp2,
                            color: '#00c853',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP2',
                        });
                        series.tpSlPriceLines.push(tp2Line);
                    }
                    if (level.sl !== null && level.sl !== undefined) {
                        const slLine = candlestickSeriesInstance.createPriceLine({
                            price: level.sl,
                            color: '#f44336',
                            lineWidth: 2,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'SL',
                        });
                        series.tpSlPriceLines.push(slLine);
                    }
                });
            }
            
            if (series.rsi) {
                series.rsi.applyOptions({ visible: toggles.rsi });
            }
            if (series.rsiOversold) {
                series.rsiOversold.applyOptions({ visible: toggles.rsi });
            }
            if (series.rsiOverbought) {
                series.rsiOverbought.applyOptions({ visible: toggles.rsi });
            }
            if (series.emaFast) {
                series.emaFast.applyOptions({ visible: toggles.emaLines });
            }
            if (series.emaSlow) {
                series.emaSlow.applyOptions({ visible: toggles.emaLines });
            }
            if (series.emaSpread) {
                series.emaSpread.applyOptions({ visible: toggles.emaSpread });
            }
        }

        function addRangeMeanReversionIndicators(chart, candlestickSeries, strategy, index) {
            const indicators = strategy.indicators;
            if (!indicators) return;
            
            // Initialize indicator series storage for this chart
            if (!indicatorSeries[index]) {
                indicatorSeries[index] = {};
            }
            const series = indicatorSeries[index];
            const toggles = indicatorToggles[index] || {
                rangeLines: true,
                entryZones: true,
                tpSlLevels: true,
                rsi: true,
                emaLines: true,
                emaSpread: false
            };
            
            // Panel 1: Price + Range overlays (main pane, pane 0)
            // Add range lines
            if (indicators.range_high && indicators.range_low && indicators.range_mid) {
                // Range High (bold line, red)
                series.rangeHigh = chart.addLineSeries({
                    color: '#f44336',
                    lineWidth: 2,
                    title: 'Range High',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: toggles.rangeLines !== false,
                });
                series.rangeHigh.setData(indicators.range_high);
                
                // Range Mid (dashed line, gray)
                series.rangeMid = chart.addLineSeries({
                    color: '#757575',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Range Mid',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: toggles.rangeLines !== false,
                });
                series.rangeMid.setData(indicators.range_mid);
                
                // Range Low (bold line, green)
                series.rangeLow = chart.addLineSeries({
                    color: '#4caf50',
                    lineWidth: 2,
                    title: 'Range Low',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: toggles.rangeLines !== false,
                });
                series.rangeLow.setData(indicators.range_low);
            }
            
            // Add entry zones (boundary lines)
            if (indicators.buy_zone_upper && indicators.range_low) {
                series.buyZoneUpper = chart.addLineSeries({
                    color: '#4caf50',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Buy Zone Upper',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: toggles.entryZones !== false,
                });
                series.buyZoneUpper.setData(indicators.buy_zone_upper);
            }
            
            if (indicators.sell_zone_lower && indicators.range_high) {
                series.sellZoneLower = chart.addLineSeries({
                    color: '#f44336',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    title: 'Sell Zone Lower',
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                    visible: toggles.entryZones !== false,
                });
                series.sellZoneLower.setData(indicators.sell_zone_lower);
            }
            
            // Add TP/SL levels (price lines on candlestick series)
            series.tpSlData = [];
            series.tpSlPriceLines = []; // Store price line references for toggling
            if (indicators.tp_sl_levels && indicators.tp_sl_levels.length > 0 && toggles.tpSlLevels !== false) {
                indicators.tp_sl_levels.forEach(level => {
                    if (level.tp1 !== null && level.tp1 !== undefined) {
                        const tp1Line = candlestickSeries.createPriceLine({
                            price: level.tp1,
                            color: '#2196F3',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP1',
                        });
                        series.tpSlPriceLines.push(tp1Line);
                    }
                    if (level.tp2 !== null && level.tp2 !== undefined) {
                        const tp2Line = candlestickSeries.createPriceLine({
                            price: level.tp2,
                            color: '#00c853',
                            lineWidth: 1,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'TP2',
                        });
                        series.tpSlPriceLines.push(tp2Line);
                    }
                    if (level.sl !== null && level.sl !== undefined) {
                        const slLine = candlestickSeries.createPriceLine({
                            price: level.sl,
                            color: '#f44336',
                            lineWidth: 2,
                            lineStyle: 1,
                            axisLabelVisible: true,
                            title: 'SL',
                        });
                        series.tpSlPriceLines.push(slLine);
                    }
                    series.tpSlData.push(level);
                });
            }
            
            // Panel 2: RSI (separate price scale on the right)
            if (indicators.rsi && indicators.rsi.length > 0) {
                series.rsi = chart.addLineSeries({
                    color: '#9C27B0',
                    lineWidth: 2,
                    title: `RSI (${indicators.rsi_period || 14})`,
                    priceLineVisible: false,
                    lastValueVisible: true,
                    priceScaleId: 'rsi',
                    visible: toggles.rsi !== false,
                });
                
                chart.priceScale('rsi').applyOptions({
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                });
                
                series.rsi.setData(indicators.rsi);
                
                // Add RSI oversold line
                if (indicators.rsi_oversold !== undefined) {
                    series.rsiOversold = chart.addLineSeries({
                        color: '#4caf50',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: `RSI Oversold (${indicators.rsi_oversold})`,
                        priceLineVisible: false,
                        priceScaleId: 'rsi',
                        visible: toggles.rsi !== false,
                    });
                    const oversoldData = indicators.rsi.map(r => ({
                        time: r.time,
                        value: indicators.rsi_oversold
                    }));
                    series.rsiOversold.setData(oversoldData);
                }
                
                // Add RSI overbought line
                if (indicators.rsi_overbought !== undefined) {
                    series.rsiOverbought = chart.addLineSeries({
                        color: '#f44336',
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        title: `RSI Overbought (${indicators.rsi_overbought})`,
                        priceLineVisible: false,
                        priceScaleId: 'rsi',
                        visible: toggles.rsi !== false,
                    });
                    const overboughtData = indicators.rsi.map(r => ({
                        time: r.time,
                        value: indicators.rsi_overbought
                    }));
                    series.rsiOverbought.setData(overboughtData);
                }
            }
            
            // Add EMA spread line if available (for range mean reversion)
            if (indicators.ema_spread_pct && indicators.ema_spread_pct.length > 0) {
                series.emaSpread = chart.addLineSeries({
                    color: '#9C27B0',
                    lineWidth: 1,
                    title: 'EMA Spread %',
                    priceLineVisible: false,
                    priceScaleId: 'emaSpread',
                    visible: toggles.emaSpread !== false,
                });
                
                chart.priceScale('emaSpread').applyOptions({
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                });
                
                series.emaSpread.setData(indicators.ema_spread_pct);
            }
        }

        function renderChart(strategy, index) {
            const chartContainer = document.getElementById(`chart-${index}`);
            if (!chartContainer) return;
            
            // Clear previous chart if exists
            if (charts[index]) {
                charts[index].remove();
                delete charts[index];
            }
            // Clear candlestick series reference
            if (candlestickSeries[index]) {
                delete candlestickSeries[index];
            }
            // Clear indicator series references
            if (indicatorSeries[index]) {
                delete indicatorSeries[index];
            }
            // Clear toggle states
            if (indicatorToggles[index]) {
                delete indicatorToggles[index];
            }
            
            if (!strategy.klines || strategy.klines.length === 0) {
                chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No chart data available.</p>';
                return;
            }
            
            // Check if library is loaded
            if (typeof LightweightCharts === 'undefined') {
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Chart library failed to load. Please refresh the page.</p>';
                return;
            }
            
            // Determine strategy type and chart height
            const strategyType = strategy.strategy_type || '';
            const isRangeMeanReversion = strategyType === 'range_mean_reversion' && 
                                        strategy.indicators && 
                                        strategy.indicators.range_high;
            const chartHeight = isRangeMeanReversion ? 800 : 500; // Taller for range mean reversion
            
            // Update chart container height
            chartContainer.style.height = chartHeight + 'px';
            
            // Create chart using shared utility
            let chart;
            try {
                chart = chartRenderer.createChart(chartContainer, chartHeight);
            } catch (e) {
                console.error('Error creating chart:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error creating chart. Please refresh the page.</p>';
                return;
            }
            
            // Store chart instance
            charts[index] = chart;
            
            // Add candlestick series using shared utility
            let candlestickSeriesInstance;
            try {
                candlestickSeriesInstance = chartRenderer.createCandlestickSeries(chart);
                // Store candlestick series reference for toggle control
                candlestickSeries[index] = candlestickSeriesInstance;
            } catch (e) {
                console.error('Error creating candlestick series:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error creating chart series. Please refresh the page.</p>';
                chart.remove();
                delete charts[index];
                return;
            }
            
            // Process klines data using shared utility
            const candlestickData = chartRenderer.processKlineData(strategy.klines); // Remove null entries
            
            if (candlestickData.length === 0) {
                chartContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No valid chart data available.</p>';
                // Clean up chart instance if it was created
                if (chart) {
                    chart.remove();
                    delete charts[index];
                }
                return;
            }
            
            // Initialize indicator series storage for this chart
            if (!indicatorSeries[index]) {
                indicatorSeries[index] = {};
            }
            
            // Create indicator toggles based on strategy type (before adding indicators)
            createIndicatorToggles(strategy, index);
            
            // Add Range Mean Reversion indicators if applicable
            if (isRangeMeanReversion) {
                try {
                    addRangeMeanReversionIndicators(chart, candlestickSeriesInstance, strategy, index);
                } catch (e) {
                    console.error('Error adding range mean reversion indicators:', e);
                }
            }
            
            // Add EMA indicator lines using shared utility (for both scalping and range mean reversion)
            const emaLines = chartRenderer.addEMALines(chart, strategy.indicators);
            if (emaLines) {
                // Store for toggle control (merge with existing if range mean reversion already added some)
                if (!indicatorSeries[index].emaFast) {
                    indicatorSeries[index].emaFast = emaLines.emaFast;
                }
                if (!indicatorSeries[index].emaSlow) {
                    indicatorSeries[index].emaSlow = emaLines.emaSlow;
                }
            }
            
            try {
                candlestickSeriesInstance.setData(candlestickData);
            } catch (e) {
                console.error('Error setting chart data:', e);
                chartContainer.innerHTML = '<p style="color: #d32f2f; padding: 20px; text-align: center;">Error loading chart data. Please refresh the page.</p>';
                chart.remove();
                delete charts[index];
                return;
            }
            
            // Get or create fixed OHLC info box above the trades table
            let ohlcBox = document.getElementById(`ohlc-info-${index}`);
            if (!ohlcBox) {
                // If box doesn't exist, create it (should exist from HTML, but fallback)
                ohlcBox = document.createElement('div');
                ohlcBox.id = `ohlc-info-${index}`;
                ohlcBox.className = 'ohlc-info-box';
                ohlcBox.innerHTML = `
                    <div class="ohlc-title">Candle Information (Hover over chart)</div>
                    <div class="ohlc-content">
                        <div class="ohlc-item">
                            <span class="ohlc-label">Open:</span>
                            <span class="ohlc-value" id="ohlc-open-${index}">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">High:</span>
                            <span class="ohlc-value high" id="ohlc-high-${index}">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Low:</span>
                            <span class="ohlc-value low" id="ohlc-low-${index}">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Close:</span>
                            <span class="ohlc-value" id="ohlc-close-${index}">-</span>
                        </div>
                        <div class="ohlc-item">
                            <span class="ohlc-label">Change:</span>
                            <span class="ohlc-value" id="ohlc-change-${index}">-</span>
                        </div>
                    </div>
                `;
                // Find the trades table and insert before it
                const strategyCard = document.getElementById(`strategy-${index}`);
                if (strategyCard) {
                    const tradesTable = strategyCard.querySelector('.trades-table');
                    if (tradesTable) {
                        tradesTable.parentNode.insertBefore(ohlcBox, tradesTable);
                    }
                }
            }
            
            // Show OHLC box when chart is visible
            if (ohlcBox) {
                ohlcBox.style.display = 'block';
            }
            
            // Setup OHLC display using shared utility
            chartRenderer.setupOHLCDisplay(chart, candlestickSeriesInstance, candlestickData, strategy.indicators, {
                ohlcBoxId: `ohlc-info-${index}`,
                openId: `ohlc-open-${index}`,
                highId: `ohlc-high-${index}`,
                lowId: `ohlc-low-${index}`,
                closeId: `ohlc-close-${index}`,
                changeId: `ohlc-change-${index}`,
                emaFastItemId: `ohlc-ema-fast-item-${index}`,
                emaFastId: `ohlc-ema-fast-${index}`,
                emaFastLabelId: `ohlc-ema-fast-label-${index}`,
                emaSlowItemId: `ohlc-ema-slow-item-${index}`,
                emaSlowId: `ohlc-ema-slow-${index}`,
                emaSlowLabelId: `ohlc-ema-slow-label-${index}`,
            });
            
            // Add markers for trades using shared utility
            const markers = chartRenderer.createTradeMarkers(strategy.trades, {
                sideField: 'side', // reports format
                pnlUsdField: 'pnl_usd', // reports format
            });
            
            if (markers.length > 0) {
                try {
                    candlestickSeriesInstance.setMarkers(markers);
                } catch (e) {
                    console.warn('Error setting markers:', e);
                }
            }
            
            // Fit content using shared utility
            chartRenderer.fitContent(chart);
        }

        // Initialize - load report on page load
        window.addEventListener('load', () => {
            loadAccounts();
            // Optionally load report automatically, or wait for user to click button
            // loadReport();
        });
    </script>
</body>
</html>

